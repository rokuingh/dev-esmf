! $Id$
!
! Earth System Modeling Framework
! Copyright 2002-2009, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
^define ESMF_FILENAME "ESMF_Attribute.F90"
!==============================================================================
!
! ESMF Attribute Module
!
! (all lines between the !BOP and !EOP markers will be included in the
! automated document processing.)
!------------------------------------------------------------------------------
! one blank line for protex processing - in case all routines here are
! marked internal (BOPI/EOPI), the output file will still have contents.
!BOP

!EOP

!------------------------------------------------------------------------------
! module definition

module ESMF_AttributeMod
!
!------------------------------------------------------------------------------
! INCLUDES
^include "ESMF.h"
#include "ESMF_TypeKindMacros.hcppF90"
^define ESMF_NO_INTEGER_1_BYTE
^define ESMF_NO_INTEGER_2_BYTE

!==============================================================================
!BOPI
! !MODULE: ESMF_AttributeMod - Attribute API
!
! !DESCRIPTION:
!
! The code in this file implements the Attribute defined type
!  and functions.  This is an
!  interface to the actual C++ Attribute class implementation 
!  in the ../../Infrastructure/Attribute dir.
!
! See the ESMF Developers Guide document for more details.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_BaseMod
  use ESMF_UtilTypesMod     ! ESMF utility types
  use ESMF_InitMacrosMod    ! ESMF initializer macros
  use ESMF_LogErrMod        ! ESMF error handling
  use ESMF_ArrayMod
  use ESMF_CompMod
  use ESMF_CplCompMod
  use ESMF_GridCompMod
  use ESMF_FieldMod
  use ESMF_FieldBundleMod
  use ESMF_GridMod
  use ESMF_StateTypesMod
  use ESMF_StateVaMod
  use ESMF_StateMod
  use ESMF_VMMod

  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private

!------------------------------------------------------------------------------
! ! ESMF_Attribute
!
!------------------------------------------------------------------------------

  type ESMF_Attribute
  sequence
    character(len=ESMF_MAXSTR)  :: attr_name
    type(ESMF_DataValue)        :: attr_value
  end type

!------------------------------------------------------------------------------
!
! !DESCRIPTION:
!     The following routines apply to {\tt ESMF\_Array}, {\tt ESMF\_Field},
!     {\tt ESMF\_FieldBundle}, {\tt ESMF\_Grid}, and {\tt ESMF\_State}.  
!
! !PUBLIC MEMBER FUNCTIONS:
!
!   Classes
      public ESMF_Attribute
      
!  Attribute methods
      public ESMF_AttributeAdd
      public ESMF_AttributeCopy
      public ESMF_AttributeRemove
      public ESMF_AttributeGet
      public ESMF_AttributeSet
      public ESMF_AttributeUpdate
      public ESMF_AttributeWrite

!EOPI 
!------------------------------------------------------------------------------
! leave the following line as-is; it will insert the cvs ident string
! into the object file for tracking purposes.
      character(*), parameter, private :: version = &
               '$Id$'
!------------------------------------------------------------------------------
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeAdd  - Create Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeAdd
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttAddPack
        module procedure ESMF_ArrayAttAddPackCstm
        module procedure ESMF_CplCompAttAddPack
        module procedure ESMF_CplCompAttAddPackCstm
        module procedure ESMF_GridCompAttAddPack
        module procedure ESMF_GridCompAttAddPackCstm
        module procedure ESMF_FieldAttAddPack
        module procedure ESMF_FieldAttAddPackCstm
        module procedure ESMF_FBundleAttAddPack
        module procedure ESMF_FieldBundleAttAddPackCstm
        module procedure ESMF_GridAttAddPack
        module procedure ESMF_GridAttAddPackCstm
        module procedure ESMF_StateAttAddPack
        module procedure ESMF_StateAttAddPackCstm
        
! !DESCRIPTION:
!     This interface provides a single entry point for methods that create
!     an Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeCopy  - Copy an Attribute or hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeCopy
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_StateAttributeCopyAll
        
! !DESCRIPTION:
!     This interface provides a single entry point for methods that copy
!     an Attribute or Attribute hierarchy.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeRemove  - Remove an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeRemove
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttRemove
        module procedure ESMF_CplCompAttRemove
        module procedure ESMF_GridCompAttRemove
        module procedure ESMF_FieldAttRemove
        module procedure ESMF_FieldBundleAttRemove
        module procedure ESMF_GridAttRemove
        module procedure ESMF_StateAttRemove

! !DESCRIPTION:
!     This interface provides a single entry point for methods that destroy
!     an Attribute or Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeGet  - Get Attributes, Attribute packages, count, 
!              info, and type
!
! !INTERFACE:
      interface ESMF_AttributeGet
   
! !PRIVATE MEMBER FUNCTIONS:
        TypeKindInterfaceMacro(ESMF_ArrayAttGet)
	TypeKindInterfaceMacro(ESMF_ArrayAttGet1D)
        module procedure ESMF_ArrayAttGetLgcl
        module procedure ESMF_ArrayAttGetLgclList
        module procedure ESMF_ArrayAttGetChar
        module procedure ESMF_ArrayAttGetCharList
        module procedure ESMF_ArrayAttGetInfoByNam
        module procedure ESMF_ArrayAttGetInfoByNum
        module procedure ESMF_ArrayAttGetCount

        TypeKindInterfaceMacro(ESMF_CplCompAttGet)
	TypeKindInterfaceMacro(ESMF_CplCompAttGet1D)
        module procedure ESMF_CplCompAttGetLgcl
        module procedure ESMF_CplCompAttGetLgclList
        module procedure ESMF_CplCompAttGetChar
        module procedure ESMF_CplCompAttGetCharList
        module procedure ESMF_CplCompAttGetInfoByNam
        module procedure ESMF_CplCompAttGetInfoByNum
        module procedure ESMF_CplCompAttGetCount

        TypeKindInterfaceMacro(ESMF_GridCompAttGet)
	TypeKindInterfaceMacro(ESMF_GridCompAttGet1D)
        module procedure ESMF_GridCompAttGetLgcl
        module procedure ESMF_GridCompAttGetLgclList
        module procedure ESMF_GridCompAttGetChar
        module procedure ESMF_GridCompAttGetCharList
        module procedure ESMF_GridCompAttGetInfoByNam
        module procedure ESMF_GridCompAttGetInfoByNum
        module procedure ESMF_GridCompAttGetCount

        TypeKindInterfaceMacro(ESMF_FieldAttGet)
	TypeKindInterfaceMacro(ESMF_FieldAttGet1D)
        module procedure ESMF_FieldAttGetLgcl
        module procedure ESMF_FieldAttGetLgclList
        module procedure ESMF_FieldAttGetChar
        module procedure ESMF_FieldAttGetCharList
        module procedure ESMF_FieldAttGetInfoByNam
        module procedure ESMF_FieldAttGetInfoByNum
        module procedure ESMF_FieldAttGetCount

        TypeKindInterfaceMacro(ESMF_FieldBundleAttGet)
	TypeKindInterfaceMacro(ESMF_FieldBundleAttGet1D)
        module procedure ESMF_FieldBundleAttGetLgcl
        module procedure ESMF_FieldBundleAttGetLgclList
        module procedure ESMF_FieldBundleAttGetChar
        module procedure ESMF_FieldBundleAttGetCharList
        module procedure ESMF_FieldBundleAttGetInfoByNam
        module procedure ESMF_FieldBundleAttGetInfoByNum
        module procedure ESMF_FieldBundleAttGetCount

        TypeKindInterfaceMacro(ESMF_GridAttGet)
	TypeKindInterfaceMacro(ESMF_GridAttGet1D)
        module procedure ESMF_GridAttGetLgcl
        module procedure ESMF_GridAttGetLgclList
        module procedure ESMF_GridAttGetChar
        module procedure ESMF_GridAttGetCharList
        module procedure ESMF_GridAttGetInfoByNam
        module procedure ESMF_GridAttGetInfoByNum
        module procedure ESMF_GridAttGetCount

        TypeKindInterfaceMacro(ESMF_StateAttGet)
	TypeKindInterfaceMacro(ESMF_StateAttGet1D)
        module procedure ESMF_StateAttGetLgcl
        module procedure ESMF_StateAttGetLgclList
        module procedure ESMF_StateAttGetChar
        module procedure ESMF_StateAttGetCharList
        module procedure ESMF_StateAttGetInfoByNam
        module procedure ESMF_StateAttGetInfoByNum
        module procedure ESMF_StateAttGetCount

! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     Attributes.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeSet  - Set Attributes and Attribute packages
!
! !INTERFACE:
      interface ESMF_AttributeSet 
   
! !PRIVATE MEMBER FUNCTIONS:
	TypeKindInterfaceMacro(ESMF_ArrayAttSet)
	TypeKindInterfaceMacro(ESMF_ArrayAttSet1D)
        module procedure ESMF_ArrayAttSetLgcl
        module procedure ESMF_ArrayAttSetLgclList
        module procedure ESMF_ArrayAttSetChar
        module procedure ESMF_ArrayAttSetCharList

	TypeKindInterfaceMacro(ESMF_CplCompAttSet)
	TypeKindInterfaceMacro(ESMF_CplCompAttSet1D)
        module procedure ESMF_CplCompAttSetLgcl
        module procedure ESMF_CplCompAttSetLgclList
        module procedure ESMF_CplCompAttSetChar
        module procedure ESMF_CplCompAttSetCharList
        module procedure ESMF_CplCompAttSetLinkCplComp
        module procedure ESMF_CplCompAttSetLinkGridComp
        module procedure ESMF_CplCompAttSetLinkState

	TypeKindInterfaceMacro(ESMF_GridCompAttSet)
	TypeKindInterfaceMacro(ESMF_GridCompAttSet1D)
        module procedure ESMF_GridCompAttSetLgcl
        module procedure ESMF_GridCompAttSetLgclList
        module procedure ESMF_GridCompAttSetChar
        module procedure ESMF_GridCompAttSetCharList
        module procedure ESMF_GridCompAttSetLinkCplComp
        module procedure ESMF_GridCompAttSetLinkGridComp
        module procedure ESMF_GridCompAttSetLinkState

	TypeKindInterfaceMacro(ESMF_FieldAttSet)
	TypeKindInterfaceMacro(ESMF_FieldAttSet1D)
        module procedure ESMF_FieldAttSetLgcl
        module procedure ESMF_FieldAttSetLgclList
        module procedure ESMF_FieldAttSetChar
        module procedure ESMF_FieldAttSetCharList

	TypeKindInterfaceMacro(ESMF_FieldBundleAttSet)
	TypeKindInterfaceMacro(ESMF_FieldBundleAttSet1D)
        module procedure ESMF_FieldBundleAttSetLgcl
        module procedure ESMF_FieldBundleAttSetLgclList
        module procedure ESMF_FieldBundleAttSetChar
        module procedure ESMF_FieldBundleAttSetCharList
        module procedure ESMF_FBundleAttSetLinkField

	TypeKindInterfaceMacro(ESMF_GridAttSet)
	TypeKindInterfaceMacro(ESMF_GridAttSet1D)
        module procedure ESMF_GridAttSetLgcl
        module procedure ESMF_GridAttSetLgclList
        module procedure ESMF_GridAttSetChar
        module procedure ESMF_GridAttSetCharList

	TypeKindInterfaceMacro(ESMF_StateAttSet)
	TypeKindInterfaceMacro(ESMF_StateAttSet1D)
        module procedure ESMF_StateAttSetLgcl
        module procedure ESMF_StateAttSetLgclList
        module procedure ESMF_StateAttSetChar
        module procedure ESMF_StateAttSetCharList
        module procedure ESMF_StateAttSetLinkFB
        module procedure ESMF_StateAttSetLinkField
        module procedure ESMF_StateAttSetLinkState

! !DESCRIPTION:
!     This interface provides a single entry point for methods that attach
!     Attributes and Attribute packages, and link Attribute hierarchies.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeWrite  - Write an Attribute or Attribute Package
!
! !INTERFACE:
      interface ESMF_AttributeWrite
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttWrite
        module procedure ESMF_CplCompAttWrite
        module procedure ESMF_GridCompAttWrite
        module procedure ESMF_FieldAttWrite
        module procedure ESMF_FBundleAttWrite
        module procedure ESMF_GridAttWrite
        module procedure ESMF_StateAttWrite

! !DESCRIPTION:
!     This interface provides a single entry point for methods that write
!     an Attribute or Attribute package.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_AttributeUpdate  - Update an Attribute hierarchy
!
! !INTERFACE:
      interface ESMF_AttributeUpdate
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_ArrayAttUpdate
        module procedure ESMF_CplCompAttUpdate
        module procedure ESMF_GridCompAttUpdate
        module procedure ESMF_FieldAttUpdate
        module procedure ESMF_FBundleAttUpdate
        module procedure ESMF_GridAttUpdate
        module procedure ESMF_StateAttUpdate

! !DESCRIPTION:
!     This interface provides a single entry point for methods that update
!     an Attribute hierarchy.
 
!EOPI
      end interface

!
!------------------------------------------------------------------------------
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add a standard Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd() 
!     subroutine ESMF_AttAddPack(<object>, convention, purpose, attpacknestflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: convention
!     character (len = *), intent(in) :: purpose
!     type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Adds an Attribute package to <object> with Attribute names according
!     to the ESG convention.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [attpacknestflag]
!           The flag to tell whether this Attribute package is to be nested or not, possible values 
!           are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeAdd  - Add a custom Attribute package
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeAdd() 
!     subroutine ESMF_AttAddPackCstm(<object>, attrList, convention, purpose, &
!     count, attpacknestflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len=*), dimension(:), intent(in) :: attrList
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(in), optional :: count   
!     type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Adds a customized Attribute package to <object>.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [attrList]
!           The list of Attribute names to specify the custom Attribute package.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [count]
!           The number of Attributes to add to the custom Attribute package.
!     \item [attpacknestflag]
!           The flag to tell whether this Attribute package is to be nested or not, possible values
!           are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeCopy - Copy an Attribute hierarchy
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeCopy() 
!     subroutine ESMF_AttributeCopyAll(<object1>, <object2>, rc)
!
! !ARGUMENTS:
!     <object1>, see below for supported values  
!     <object2>, see below for supported values 
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Copies an Attribute hierarchy from <object1> to <object2>.
!     Supported values for <object1> are:
!     \begin{description}
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for <object2> are:
!     \begin{description}
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!           An {\tt ESMF} object.
!     \item [<object2>]
!           An {\tt ESMF} object.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet  - Get an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeGet(<object>, name, <value argument>, &
!                            <defaultvalue argument>, convention, purpose, &
!                            itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     <value argument>, see below for supported values
!     <defaultvalue argument>, see below for supported values   
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: itemCount
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns an Attribute value from the <object>, or from the Attribute package
!     specified by {\tt convention} and {\tt purpose}.  A default value 
!     argument may be given if a return code is not desired when the 
!     Attribute is not found.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for <value argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: value
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(out) :: valueList
!     \item integer(ESMF\_KIND\_I8), intent(out) :: value
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(out) :: valueList
!     \item real (ESMF\_KIND\_R4), intent(out) :: value
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(out) :: valueList
!     \item real (ESMF\_KIND\_R8), intent(out) :: value
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(out) :: valueList
!     \item logical, intent(out) :: value
!     \item logical, dimension(:), intent(out) :: valueList
!     \item character (len = *), intent(out), value
!     \item character (len = *), dimension(count), intent(out), valueList
!     \end{description}
!     Supported values for <defaultvalue argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(out) :: defaultvalue
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(out) :: defaultvalueList
!     \item integer(ESMF\_KIND\_I8), intent(out) :: defaultvalue
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(out) :: defaultvalueList
!     \item real (ESMF\_KIND\_R4), intent(out) :: defaultvalue
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(out) :: defaultvalueList
!     \item real (ESMF\_KIND\_R8), intent(out) :: defaultvalue
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(out) :: defaultvalueList
!     \item logical, intent(out) :: defaultvalue
!     \item logical, dimension(:), intent(out) :: defaultvalueList
!     \item character (len = *), intent(out), defaultvalue
!     \item character (len = *), dimension(:), intent(out), defaultvalueList
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [name]
!           The name of the Attribute to retrieve.
!     \item [<value argument>]
!           The value of the named Attribute.
!     \item [<defaultvalue argument>]
!           The default value of the named Attribute.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [itemCount]
!           The number of items in a multi-valued Attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get the Attribute count
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetCount(<object>, count, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     integer, intent(out) :: count
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns the Attribute count for <object>
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [count] 
!           The Attribute count for <object>.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by name
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetInfoByNam(<object>, name, typekind, itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     type(ESMF_TypeKind), intent(out), optional :: typekind
!     integer, intent(out), optional :: itemCount   
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns information associated with the named Attribute, 
!     including {\tt typekind} and {\tt itemCount}.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [name]
!           The name of the Attribute to query.
!     \item [typekind]
!           The typekind of the Attribute.
!     \item [itemCount]
!           The number of items in this Attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeGet - Get Attribute info by index number
!
! !INTERFACE:
!     ! Private name; call using ESMF_AttributeGet() 
!     subroutine ESMF_AttributeGetInfoByNum(<object>, attributeIndex, name, &
!       typekind, itemcount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     integer, intent(in) :: attributeIndex
!     character (len = *), intent(out) :: name
!     type(ESMF_TypeKind), intent(out), optional :: typekind
!     integer, intent(out), optional :: itemCount   
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Returns information associated with the indexed Attribute, 
!     including {\tt name}, {\tt typekind} and {\tt itemCount}.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [attributeIndex]
!           The index number of the Attribute to query.
!     \item [name]
!           Returns the name of the Attribute.
!     \item [typekind]
!           The typekind of the Attribute.
!     \item [itemCount]
!           Returns the number of items in this Attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeRemove - Remove an Attribute or Attribute package
!
! !INTERFACE:
!     subroutine ESMF_AttributeRemove(<object>, name, convention, purpose, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values
!     character (len = *), intent(in), optional :: name
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Removes an Attribute on <object>.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [name]
!           The name of the Attribute to remove.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!     NOTE:  An entire Attribute package can be removed by specifying 
!            {\tt convention} and {\tt purpose} only, without {\tt name}.  By specifying
!            {\tt convention}, {\tt purpose}, and {\tt name} an Attribute will be removed 
!            from the corresponding Attribute package, if it exists.  An 
!            Attribute can be removed directly from <object> by specifying
!            {\tt name}, without {\tt convention} and {\tt purpose}.
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Set an Attribute
!
! !INTERFACE:
!     subroutine ESMF_AttributeSet(<object>, name, <value argument>, &
!                                 convention, purpose, itemCount, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in) :: name
!     <value argument>, see below for supported values
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     integer, intent(in), optional :: itemCount
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Attaches an Attribute to <object>, or sets an Attribute on an 
!     Attribute package.
!     The Attribute has a {\tt name} and either a {\tt value} or a 
!     {\tt valueList}, with an {\tt itemCount}, and a {\tt convention} and {\tt purpose}.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!     Supported values for the <value argument> are:
!     \begin{description}
!     \item integer(ESMF\_KIND\_I4), intent(in) :: value
!     \item integer(ESMF\_KIND\_I4), dimension(:), intent(in) :: valueList
!     \item integer(ESMF\_KIND\_I8), intent(in) :: value
!     \item integer(ESMF\_KIND\_I8), dimension(:), intent(in) :: valueList
!     \item real (ESMF\_KIND\_R4), intent(in) :: value
!     \item real (ESMF\_KIND\_R4), dimension(:), intent(in) :: valueList
!     \item real (ESMF\_KIND\_R8), intent(in) :: value
!     \item real (ESMF\_KIND\_R8), dimension(:), intent(in) :: valueList
!     \item logical, intent(in) :: value
!     \item logical, dimension(:), intent(in) :: valueList
!     \item character (len = *), intent(in), :: value
!     \item character (len = *), dimension(:), intent(in), :: valueList
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [name]
!           The name of the Attribute to set.
!     \item [<value argument>]
!           The value of the Attribute to set.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [itemCount]
!           The number of items in a multi-valued Attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

!-------------------------------------------------------------------------
!  Macro versions of the routines
!-------------------------------------------------------------------------

#define AttAddPackCustomMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttAddPackCstm" @\
!BOPI @\
! !IROUTINE: mclass##AttAddPackCstm - Create the Attribute package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeAdd() @\
      subroutine mclass##AttAddPackCstm(mthis, attrList, convention, & @\
      purpose, count, attpacknestflag, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), dimension(:), intent(in) :: attrList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: count @\
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Sets up a custom Attribute package for the object, or adds to an  @\
!     existing Attribute package. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!      An ESMF object. @\
!     \item [convention] @\
!      The convention of the Attribute package. @\
!     \item [purpose] @\
!      The purpose of the Attribute package. @\
!     \item [attrList] @\
!      An array of character strings specifying the names of the user defined Attributes @\
!     \item [count] @\
!      The count of the number of Attributes to add to the package @\
!     \item [attpacknestflag] @\
!      The flag to tell whether this Attribute package is to be nested or not, possible values @\
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}. @\
!     \item [{[rc]}]  @\
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, directional, localCount, limit                           ! Error status @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_AttPackNestFlag) :: attpacknest @\
 @\
      ! Initialize return code; assume failure until success is certain @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check input variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(count)) then @\
	localCount = count @\
      else @\
	localCount = size(attrList) @\
      end if @\
 @\
      if (present(attpacknestflag)) then @\
        attpacknest = attpacknestflag @\
      else @\
        attpacknest = ESMF_ATTPACKNEST_OFF @\
      endif @\
 @\
      limit = size(attrList) @\
      if (localCount > limit .OR. localCount .le. 0) then @\
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, & @\
                                    "invalid Count parameter", & @\
                                     ESMF_CONTEXT, rc)) return @\
      endif @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      do i = 1, localCount @\
       @\
        if (directional == 0) then @\
        call c_ESMC_AttPackCreate(mthisfield, attrList(i), fconvention, & @\
          fpurpose, fobject, attpacknest, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        else if (directional == 1) then @\
        call c_ESMC_AttPackCreate(mthisfield, attrList(i), convention, & @\
          fpurpose, fobject, attpacknest, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        else if (directional == 2) then @\
        call c_ESMC_AttPackCreate(mthisfield, attrList(i), fconvention, & @\
          purpose, fobject, attpacknest, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        else if (directional == 3) then @\
        call c_ESMC_AttPackCreate(mthisfield, attrList(i), convention, & @\
          purpose, fobject, attpacknest, localrc) @\
        if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        end if @\
      end do @\
       @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttAddPackCstm @\

!------------------------------------------------------------------------------

#define AttRemoveMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttRemove" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeRemove  - Remove an Attribute or Attribute Package @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeRemove() @\
      subroutine mclass##AttRemove(mthis, name, convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in), optional :: name @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
! @\
! !DESCRIPTION: @\
!     Removes an Attribute on the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to destroy. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
   @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 3 .AND. .not.(present(name))) then @\
      call c_ESMC_AttPackRemove(mthisfield, convention, & @\
        purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 0 .AND. present(name)) then @\
      call c_ESMC_AttPackRemoveAttribute(mthisfield, name, fconvention, & @\
        fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 1 .AND. present(name)) then @\
      call c_ESMC_AttPackRemoveAttribute(mthisfield, name, convention, & @\
        fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 2 .AND. present(name)) then @\
      call c_ESMC_AttPackRemoveAttribute(mthisfield, name, fconvention, & @\
        purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 3 .AND. present(name)) then @\
      call c_ESMC_AttPackRemoveAttribute(mthisfield, name, convention, & @\
        purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
    else if (present(name)) then @\
 @\
      call c_ESMC_AttributeRemove(mthisfield, name, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttRemove @\

!------------------------------------------------------------------------------

#define AttGetDoc() \
!BOPI @\
!EOPI @\

#define AttGetMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
@\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet##mtypekind(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
 @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(out) :: value @\
      mtype(ESMF_KIND_##mtypekind), intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The real value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The real default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end if @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
         @\
      else @\
 @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet##mtypekind @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve an Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGet1D##mtypekind(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
 @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(out) :: valueList @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(inout), optional :: defaultvalueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: itemCount    @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns an Attribute from the object. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The real value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The real default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional, litemCount @\
      integer :: limit @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      litemCount = size(valueList) @\
 @\
      limit = size(valueList) @\
      if (litemCount > limit .OR. litemCount .le. 0) then @\
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, & @\
                                    "invalid itemCount argument", & @\
                                     ESMF_CONTEXT, rc)) return @\
      endif @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end if @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalueList)) then @\
          valueList = defaultvalueList @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      else @\
        if(present(defaultvalueList)) then @\
          valueList = defaultvalueList @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
    if (present(itemCount)) then @\
      itemCount = litemCount @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttGetLogicalMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgcl(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(out) :: value @\
      logical, intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical Attribute from the {\tt array}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The logical value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The logical default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: localvalue, present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        fconvention, fpurpose, fobject, localrc) @\
      value = localvalue   @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        convention, fpurpose, fobject, localrc) @\
      value = localvalue   @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        fconvention, purpose, fobject, localrc) @\
      value = localvalue   @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        convention, purpose, fobject, localrc) @\
      value = localvalue   @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end if @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) @\
      value = localvalue @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetLgclList(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, dimension(:), intent(out) :: valueList @\
      logical, dimension(:), intent(inout), optional :: defaultvalueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: itemCount    @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a logical list Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The logical values of the named Attribute. @\
!     \item [defaultvalueList] @\
!           The logical default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of values in the Attribute. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional, litemCount @\
      integer :: limit @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
      type(ESMF_Logical), allocatable :: localvalueList(:) @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      litemCount = size(valueList) @\
 @\
      limit = size(valueList) @\
      if (litemCount > limit .OR. litemCount .le. 0) then @\
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, & @\
                                    "invalid itemCount argument", & @\
                                     ESMF_CONTEXT, rc)) return @\
      endif @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      allocate (localvalueList(limit)) @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, & @\
        fconvention, fpurpose, fobject, localrc) @\
      valueList = localvalueList @\
      deallocate (localvalueList) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      allocate (localvalueList(limit)) @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, & @\
        convention, fpurpose, fobject, localrc) @\
      valueList = localvalueList @\
      deallocate (localvalueList) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      allocate (localvalueList(limit)) @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, & @\
        fconvention, purpose, fobject, localrc) @\
      valueList = localvalueList @\
      deallocate (localvalueList) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      allocate (localvalueList(limit)) @\
      call c_ESMC_AttPackGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, & @\
        convention, purpose, fobject, localrc) @\
      valueList = localvalueList @\
      deallocate (localvalueList) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end if @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalueList)) then @\
          valueList = defaultvalueList @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      allocate (localvalueList(limit)) @\
      call c_ESMC_AttributeGetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, localrc) @\
      valueList = localvalueList @\
      deallocate (localvalueList) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else @\
        if(present(defaultvalueList)) then @\
          valueList = defaultvalueList @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    endif @\
@\
    if (present(itemCount)) then @\
      itemCount = litemCount @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetLgclList @\

!------------------------------------------------------------------------------

#define AttGetCharacterMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetChar" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetChar(mthis, name, value, defaultvalue, & @\
        convention, purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(out) :: value @\
      character (len = *), intent(inout), optional :: defaultvalue @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [value] @\
!           The character value of the named Attribute. @\
!     \item [defaultvalue] @\
!           The character default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional  @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
        convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
        fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetChar(mthisfield, name, value, & @\
        convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end if @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetChar(mthisfield, name, value, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else @\
        if(present(defaultvalue)) then @\
          value = defaultvalue @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCharList" @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Retrieve a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetCharList(mthis, name, valueList, & @\
        defaultvalueList, convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len=*), dimension(:), intent(out) :: valueList @\
      character (len=*), dimension(:), intent(in), optional :: defaultvalueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: itemCount @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns a character Attribute from the object. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to retrieve. @\
!     \item [valueList] @\
!           The character list values of the named Attribute. @\
!     \item [defaultvalueList] @\
!           The character list default value of the named Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The itemCount of the character items to retrieve @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, directional, litemCount, limit @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: present_flag @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      litemCount = size(valueList) @\
 @\
      limit = size(valueList) @\
      if (litemCount > limit .OR. litemCount .le. 0) then @\
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, & @\
                                    "invalid itemCount argument", & @\
                                     ESMF_CONTEXT, rc)) return @\
      endif @\
 @\
      do  i=1,litemCount @\
        lens(i) = len (valueList) @\
      enddo @\
       @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, fconvention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, fpurpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, convention, fpurpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, fconvention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, fconvention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackIsPresent(mthisfield, name, convention, purpose, & @\
        fobject, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      if (present_flag == ESMF_TRUE) then @\
      call c_ESMC_AttPackGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, convention, purpose, fobject, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
      end if @\
      if (present_flag == ESMF_FALSE) then @\
        if(present(defaultvalueList)) then @\
          do i=1,litemCount @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
          if (present(rc)) rc = ESMF_SUCCESS @\
          return @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    else @\
       @\
      call c_ESMC_AttributeIsPresent(mthisfield, name, present_flag, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
 @\
      if (present_flag == ESMF_TRUE) then @\
 @\
      call c_ESMC_AttributeGetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, lens, valueString, localrc) @\
      if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else @\
        if(present(defaultvalueList)) then @\
          do i=1,litemCount @\
            valueList(i) = defaultvalueList(i) @\
          enddo @\
          if (present(rc)) rc = ESMF_SUCCESS @\
          return @\
        else  @\
          if(ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
        endif @\
      endif @\
 @\
    endif @\
 @\
      j = 1 @\
      do  i=1,litemCount @\
        valueList(i) = valueString(j:(j+lens(i)-1)) @\
        j = j + lens(i) @\
      enddo @\
 @\
    if (present(itemCount)) then @\
      itemCount = litemCount @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCharList @\

!------------------------------------------------------------------------------

#define GetCountNameNumberMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetCount" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query the number of Attributes @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet()  @\
      subroutine mclass##AttGetCount(mthis, count, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      integer, intent(out) :: count    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns the number of Attributes associated with the given object  @\
!     in the argument {\tt count}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [count] @\
!           The number of Attributes associated with this object. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetCount(mthisfield, count, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetCount @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfoByNam" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by name @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetInfoByNam(mthis, name, typekind, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character(len=*), intent(in) :: name @\
      type(ESMF_TypeKind), intent(out), optional :: typekind @\
      integer, intent(out), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Returns information associated with the named Attribute,  @\
!     including {\tt typekind} and {\tt itemCount}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to query. @\
!     \item [{[typekind]}] @\
!           The typekind of the Attribute. @\
!     \item [{[itemCount]}] @\
!           The number of items in this Attribute.  For character types, @\
!           the length of the character string. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc              @\
      type(ESMF_TypeKind) :: localTk @\
      integer :: litemCount @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetInfoName(mthisfield, name, & @\
        localTk, litemCount, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
      if (present(typekind)) typekind = localTk @\
      if (present(itemCount)) itemCount = litemCount @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetInfoByNam @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttGetInfoByNum" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeGet - Query State Attributes by index number @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeGet() @\
      subroutine mclass##AttGetInfoByNum(mthis, attributeIndex, name, & @\
        typekind, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      integer, intent(in) :: attributeIndex @\
      character(len=*), intent(out) :: name @\
      type(ESMF_TypeKind), intent(out), optional :: typekind @\
      integer, intent(out), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Returns information associated with the indexed Attribute,  @\
!      including {\tt name}, {\tt typekind} and {\tt itemCount}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [attributeIndex] @\
!           The index number of the Attribute to query. @\
!     \item [name] @\
!           Returns the name of the Attribute. @\
!     \item [{[typekind]}] @\
!           The typekind of the Attribute. @\
!     \item [{[itemCount]}] @\
!           Returns the number of items in this Attribute.  For character types, @\
!           this is the length of the character string. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc  @\
      character(len=len(name)) :: localName @\
      type(ESMF_TypeKind) :: localTk @\
      integer :: litemCount @\
 @\
      ! Initialize  @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      call c_ESMC_AttributeGetInfoNum(mthisfield, attributeIndex, & @\
        localName, localTk, litemCount, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
      name = localName @\
      if (present(typekind)) typekind = localTk @\
      if (present(itemCount)) itemCount = litemCount @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttGetInfoByNum @\
 @\
      
!------------------------------------------------------------------------------

#define AttSetDoc() \
!BOPI @\
!EOPI @\

#define AttSetMacro(mtype, mtypekind, mclass, mthis, mthisfield) \
 @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSet" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a 4-byte integer Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSet##mtypekind(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Attaches a 4-byte integer Attribute to the object. @\
!      The Attribute has a {\tt name} and a {\tt value}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The integer value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional  @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, & @\
        convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
    else @\
      call c_ESMC_AttributeSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, 1, value, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSet##mtypekind @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSet1D" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a 4-byte integer list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSet1D##mtypekind(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      mtype(ESMF_KIND_##mtypekind), dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches a 4-byte integer list Attribute to the object. @\
!     The Attribute has a {\tt name} and a {\tt valueList}. @\
!     The number of integer items in the {\tt valueList} is @\
!     given by {\tt itemCount}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [valueList] @\
!           The integer values of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of integers in the {\tt valueList}. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
@\
      integer :: localrc, directional, litemCount @\
      integer :: limit @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      limit = size(valueList) @\
      if (litemCount > limit .OR. litemCount .le. 0) then @\
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, & @\
                                    "invalid itemCount argument", & @\
                                     ESMF_CONTEXT, rc)) return @\
      endif @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, & @\
        convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
    else @\
       @\
      call c_ESMC_AttributeSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_##mtypekind, litemCount, valueList, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSet1D##mtypekind @\

!------------------------------------------------------------------------------

#define AttSetLogicalMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetLgcl" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a logical Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetLgcl(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches a logical Attribute to the {\tt array}. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The logical true/false value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical) :: localvalue @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      localvalue = value @\
      if (directional == 0) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, & @\
        convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
    else @\
 @\
      localvalue = value @\
      call c_ESMC_AttributeSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, 1, localvalue, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetLgcl @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetLgclList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a logical list Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetLgclList(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      logical, dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount    @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!     Attaches a logical list Attribute to the {\tt array}. @\
!     The Attribute has a {\tt name} and a {\tt valueList}. @\
!     The number of logical items in the {\tt valueList} is @\
!     given by {\tt itemCount}. @\
!  @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The logical true/false values of the Attribute. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [itemCount] @\
!           The number of logicals in the {\tt valueList}. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional, litemCount @\
      integer :: limit @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      type(ESMF_Logical), allocatable :: localvalueList(:) @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      limit = size(valueList) @\
      if (litemCount > limit .OR. litemCount .le. 0) then @\
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, & @\
                                    "invalid itemCount argument", & @\
                                     ESMF_CONTEXT, rc)) return @\
      endif @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      allocate (localvalueList(litemCount)) @\
      localvalueList = valueList @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, & @\
        fconvention, fpurpose, fobject, localrc) @\
      deallocate (localvalueList) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 1) then @\
      allocate (localvalueList(litemCount)) @\
      localvalueList = valueList @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, & @\
        convention, fpurpose, fobject, localrc) @\
      deallocate (localvalueList) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 2) then @\
      allocate (localvalueList(litemCount)) @\
      localvalueList = valueList @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, & @\
        fconvention, purpose, fobject, localrc) @\
      deallocate (localvalueList) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 3) then @\
      allocate (localvalueList(litemCount)) @\
      localvalueList = valueList @\
      call c_ESMC_AttPackSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, & @\
        convention, purpose, fobject, localrc) @\
      deallocate (localvalueList) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
    else @\
 @\
      allocate (localvalueList(litemCount)) @\
      localvalueList = valueList @\
      call c_ESMC_AttributeSetValue(mthisfield, name, & @\
        ESMF_TYPEKIND_LOGICAL, litemCount, localvalueList, localrc) @\
      deallocate (localvalueList) @\
 @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
 @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetLgclList @\

!------------------------------------------------------------------------------

#define AttSetCharacterMacro(mclass, mthis, mthisfield) \
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetChar" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetChar(mthis, name, value, convention, & @\
        purpose, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis   @\
      character (len = *), intent(in) :: name @\
      character (len = *), intent(in) :: value @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(out), optional :: rc    @\
 @\
! @\
! !DESCRIPTION: @\
!      Attaches a character Attribute to the {\tt array}. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, directional @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
       @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
        ESMF_TYPEKIND_CHARACTER, fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
        ESMF_TYPEKIND_CHARACTER, convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
        ESMF_TYPEKIND_CHARACTER, fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackSetChar(mthisfield, name, value, & @\
        ESMF_TYPEKIND_CHARACTER, convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
    else @\
 @\
      call c_ESMC_AttributeSetChar(mthisfield, name, value, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetChar @\
 @\
!------------------------------------------------------------------------------ @\
^undef  ESMF_METHOD @\
^define ESMF_METHOD "ESMF_AttSetCharList" @\
 @\
!BOPI @\
! !IROUTINE: ESMF_AttributeSet - Set a character Attribute list @\
! @\
! !INTERFACE: @\
      ! Private name; call using ESMF_AttributeSet() @\
      subroutine mclass##AttSetCharList(mthis, name, valueList, & @\
        convention, purpose, itemCount, rc) @\
! @\
! !ARGUMENTS: @\
      type(mclass), intent(inout) :: mthis @\
      character(len=*), intent(in) :: name @\
      character (len = *), dimension(:), intent(in) :: valueList @\
      character (len = *), intent(in), optional :: convention @\
      character (len = *), intent(in), optional :: purpose @\
      integer, intent(in), optional :: itemCount @\
      integer, intent(out), optional :: rc @\
 @\
! @\
! !DESCRIPTION: @\
!      Attaches a character Attribute to the {\tt array}. @\
!     The Attribute has a {\tt name} and a {\tt value}. @\
! @\
!     The arguments are: @\
!     \begin{description} @\
!     \item [mthis] @\
!           An ESMF object. @\
!     \item [name] @\
!           The name of the Attribute to add. @\
!     \item [value] @\
!           The character value of the Attribute to add. @\
!     \item [convention] @\
!           The convention of the Attribute package. @\
!     \item [purpose] @\
!           The purpose of the Attribute package. @\
!     \item [{[rc]}]  @\
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors. @\
!     \end{description} @\
! @\
! @\
!EOPI @\
 @\
      integer :: localrc, i, j, directional, litemCount, limit @\
      character(len=*), parameter :: fconvention='N/A' @\
      character(len=*), parameter :: fpurpose='N/A' @\
      character(len=*), parameter :: fobject=#mthis @\
      integer, dimension(size(valueList)) :: lens @\
      character(len=(size(valueList)*len(valueList))) :: valueString @\
 @\
      ! Initialize @\
      localrc = ESMF_RC_NOT_IMPL @\
      if (present(rc)) rc = ESMF_RC_NOT_IMPL @\
 @\
      ! check variables @\
      ESMF_INIT_CHECK_DEEP(mclass##GetInit,mthis,rc) @\
 @\
      if (present(itemCount)) then @\
	litemCount = itemCount @\
      else @\
	litemCount = size(valueList) @\
      end if @\
 @\
      limit = size(valueList) @\
      if (litemCount > limit .OR. litemCount .le. 0) then @\
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, & @\
                                    "invalid itemCount argument", & @\
                                     ESMF_CONTEXT, rc)) return @\
      endif @\
 @\
      directional = 0 ! neither convention nor purpose @\
 @\
      j = 1 @\
      do  i=1,litemCount @\
        lens(i) = len_trim(valueList(i)) @\
        valueString(j:(j+lens(i)-1)) = valueList(i) @\
        j = j + lens(i) @\
      enddo @\
 @\
    if (present(convention) .OR. present(purpose)) then @\
 @\
      if (present(convention)) then @\
        directional = 1 ! convention only @\
      endif @\
 @\
      if (present(purpose)) then @\
        directional = 2 ! purpose only @\
      endif @\
 @\
      if (present(convention) .AND. present(purpose)) then @\
        directional = 3 ! convention and purpose @\
      endif @\
 @\
      if (directional == 0) then @\
      call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, fconvention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 1) then @\
      call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, convention, fpurpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 2) then @\
      call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, fconvention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      else if (directional == 3) then @\
      call c_ESMC_AttPackSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, convention, purpose, fobject, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                ESMF_ERR_PASSTHRU, & @\
                                ESMF_CONTEXT, rc)) return @\
      end if @\
    else @\
 @\
      call c_ESMC_AttributeSetCharList(mthisfield, name, ESMF_TYPEKIND_CHARACTER, & @\
        litemCount, valueString, lens, localrc) @\
      if (ESMF_LogMsgFoundError(localrc, & @\
                                  ESMF_ERR_PASSTHRU, & @\
                                  ESMF_CONTEXT, rc)) return @\
    endif @\
 @\
      if (present(rc)) rc = ESMF_SUCCESS @\
 @\
      end subroutine mclass##AttSetCharList @\


!-------------------------------------------------------------------------
!  ARRAY
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_ArrayAttAddPack"
!BOPI
! !IROUTINE: ESMF_ArrayAttAddPack - Create an array Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_ArrayAttAddPack(array, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt array}.
!     The Attribute package defines the convention, purpose, and object type 
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!      An {\tt ESMF\_Array} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='array'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'standard_name'
      character (len=*), parameter :: name3 = 'long_name'
      character (len=*), parameter :: name4 = 'units'
      character (len=*), parameter :: name5 = 'import'
      character (len=*), parameter :: name6 = 'export'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

     call c_ESMC_AttPackCreate(array, name1, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(array, name2, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(array, name3, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(array, name4, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(array, name5, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(array, name6, fconvention, &
        fpurpose, fobject, attpacknest, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_Array, array, array)
AttRemoveMacro(ESMF_Array, array, array)

TypeKind3DeclarationMacro(AttGet, ESMF_Array, array, array)
AttGetLogicalMacro(ESMF_Array, array, array)
AttGetCharacterMacro(ESMF_Array, array, array)

GetCountNameNumberMacro(ESMF_Array, array, array)      

TypeKind3DeclarationMacro(AttSet, ESMF_Array, array, array)
AttSetLogicalMacro(ESMF_Array, array, array)
AttSetCharacterMacro(ESMF_Array, array, array)

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_ArrayAttUpdate"
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeUpdate()
      subroutine ESMF_ArrayAttUpdate(array, vm, rootList, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array
      type(ESMF_VM), intent(in) :: vm
      integer, dimension(:), intent(in) :: rootList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Update an Attribute hierarchy.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!      An {\tt ESMF\_Array} object.
!     \item [vm]
!      The virtural machine over which this Attribute hierarchy 
!      should be updated.
!     \item [rootList]
!      The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, count                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

      call ESMF_ArrayValidate(array, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      count = size(rootList)
      call c_ESMC_AttributeUpdate(array, vm, rootList, count, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayAttUpdate

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_ArrayAttWrite"
!BOPI
! !IROUTINE: ESMF_AttributeWrite - Print the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeWrite()
      subroutine ESMF_ArrayAttWrite(array, convention, purpose, &
        attwriteflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Array), intent(inout) :: array  
      character (len = *), intent(in), optional :: convention
      character (len = *), intent(in), optional :: purpose
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Print the Attribute package for the {\tt array}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!      An {\tt ESMF\_Array} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attwriteflag]
!      Flag to determine the format for writing the Attributes.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, directional                           ! Error status
      character(len=*), parameter :: fconvention='N/A'
      character(len=*), parameter :: fpurpose='N/A'
      character(len=*), parameter :: fobject='array'
      character(len=*), parameter :: ftarobj='array'
      type(ESMF_AttWriteFlag) :: writeflag

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_ArrayGetInit,array,rc)

      call ESMF_ArrayValidate(array, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      directional = 0
      if (present(convention)) then
        directional = 1 ! convention only
      endif
      
      if (present(purpose)) then
        directional = 2 ! purpose only
      endif
      
      if (present(convention) .AND. present(purpose)) then
        directional = 3 ! convention and purpose
      endif
      
      if (present(attwriteflag)) then
        writeflag = attwriteflag
      else
        writeflag = ESMF_ATTWRITE_TAB
      endif
      
      if (directional == 0) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(array, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(array, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 1) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(array, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(array, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 2) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(array, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(array, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 3) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(array, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(array, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      end if
      
      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_ArrayAttWrite

!-------------------------------------------------------------------------
!  CplComp
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_CplCompAttAddPack"
!BOPI
! !IROUTINE: ESMF_CplCompAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_CplCompAttAddPack(comp, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_CplComp), intent(inout) :: comp  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt comp}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [comp]
!      An {\tt ESMF\_CplComp} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='comp'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'full_name'
      character (len=*), parameter :: name3 = 'version'
      character (len=*), parameter :: name4 = 'discipline'
      character (len=*), parameter :: name5 = 'physical_domain'
      character (len=*), parameter :: name6 = 'agency'
      character (len=*), parameter :: name7 = 'institution'
      character (len=*), parameter :: name8 = 'author'
      character (len=*), parameter :: name9 = 'coding_language'
      character (len=*), parameter :: name10 = 'model_component_framework'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(comp%compp%base, name1, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name2, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name3, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name4, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name5, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name6, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name7, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name8, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name9, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name10, fconvention, &
        fpurpose, fobject, attpacknest, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_CplCompAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_CplComp, comp, comp%compp%base)
AttRemoveMacro(ESMF_CplComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_CplComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_CplComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_CplComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_CplComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_CplComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_CplComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_CplComp, comp, comp%compp%base)

!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Link a Component Attribute hierarchy to that of
!                                {\bf a Component or State}
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeSet()
!      subroutine ESMF_CplCompAttSetLink(<object1>, <object2>, rc)
!
! !ARGUMENTS:
!      <object1>, see below for supported values  
!      <object2>, see below for supported values
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attaches a {\tt CplComp} or {\tt GridComp} Attribute hierarchy to the 
!     hierarchy of a {\tt CplComp}, {\tt GridComp}, or {\tt State}.
!      
!     Supported values for the <object1> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp1
!     \item type(ESMF\_GridComp), intent(inout) :: comp1
!     \end{description}
!     Supported values for the <object2> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp2
!     \item type(ESMF\_GridComp), intent(inout) :: comp2
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [<object1>]
!       The ``parent'' object in the Attribute hierarchy link.
!     \item [<object2>]
!       The ``child'' object in the Attribute hierarchy link.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_CplCompAttSetLinkCplComp"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link an CplComp Attribute hierarchy to a CplComp
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_CplCompAttSetLinkCplComp(comp1, comp2, rc)
!
! !ARGUMENTS:
      type(ESMF_CplComp), intent(inout) :: comp1
      type(ESMF_CplComp), intent(inout)  :: comp2
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a CplComp to a CplComp in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [comp1]
!      An {\tt ESMF\_CplComp} object.
!     \item [comp2]
!      An {\tt ESMF\_CplComp} object.
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc)

      call ESMF_CplCompValidate(comp1, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc)

      call ESMF_CplCompValidate(comp2, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(comp1%compp%base, comp2%compp%base, &
        localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_CplCompAttSetLinkCplComp

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_CplCompAttSetLinkGridComp"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link an CplComp Attribute hierarchy to a GridComp
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_CplCompAttSetLinkGridComp(comp1, comp2, rc)
!
! !ARGUMENTS:
      type(ESMF_CplComp), intent(inout) :: comp1
      type(ESMF_GridComp), intent(inout)  :: comp2
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a CplComp to a GridComp in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [comp1]
!      An {\tt ESMF\_CplComp} object.
!     \item [comp2]
!      An {\tt ESMF\_GridComp} object.
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc)

      call ESMF_CplCompValidate(comp1, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc)

      call ESMF_GridCompValidate(comp2, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(comp1%compp%base, comp2%compp%base, &
        localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_CplCompAttSetLinkGridComp

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_CplCompAttSetLinkState"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link an CplComp Attribute hierarchy to a State
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_CplCompAttSetLinkState(comp1, state, rc)
!
! !ARGUMENTS:
      type(ESMF_CplComp), intent(inout) :: comp1
      type(ESMF_State), intent(inout)  :: state
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a CplComp to a Field in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [comp1]
!      An {\tt ESMF\_CplComp} object.
!     \item [state]
!      An {\tt ESMF\_State} object.
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp1,rc)

      call ESMF_CplCompValidate(comp1, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(comp1%compp%base, state%statep%base, &
        localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_CplCompAttSetLinkState

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_CplCompAttUpdate"
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeUpdate()
      subroutine ESMF_CplCompAttUpdate(comp, vm, rootList, rc)
!
! !ARGUMENTS:
      type(ESMF_CplComp), intent(inout) :: comp
      type(ESMF_VM), intent(in) :: vm
      integer, dimension(:), intent(in) :: rootList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Update an Attribute hierarchy.
!
!     The arguments are:
!     \begin{description}
!     \item [comp]
!      An {\tt ESMF\_CplComp} object.
!     \item [vm]
!      The virtural machine over which this Attribute hierarchy 
!      should be updated.
!     \item [rootList]
!      The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, count                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc)

      call ESMF_CplCompValidate(comp, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      count = size(rootList)
      call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_CplCompAttUpdate

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_CplCompAttWrite"
!BOPI
! !IROUTINE: ESMF_CplCompAttWrite - Print the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeWrite()
      subroutine ESMF_CplCompAttWrite(comp, convention, purpose, &
        attwriteflag, rc)
!
! !ARGUMENTS:
      type(ESMF_CplComp), intent(inout) :: comp  
      character (len = *), intent(in), optional :: convention
      character (len = *), intent(in), optional :: purpose
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Write the Attribute package for the {\tt comp}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [comp]
!      An {\tt ESMF\_CplComp} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attwriteflag]
!      Flag to determine the format for writing the Attributes.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, directional                           ! Error status
      character(len=*), parameter :: fconvention='N/A'
      character(len=*), parameter :: fpurpose='N/A'
      character(len=*), parameter :: fobject='comp'
      character(len=*), parameter :: ftarobj='field'
      type(ESMF_AttWriteFlag) :: writeflag

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp,rc)

      call ESMF_CplCompValidate(comp, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      directional = 0
      if (present(convention)) then
        directional = 1 ! convention only
      endif
      
      if (present(purpose)) then
        directional = 2 ! purpose only
      endif
      
      if (present(convention) .AND. present(purpose)) then
        directional = 3 ! convention and purpose
      endif
      
      if (present(attwriteflag)) then
        writeflag = attwriteflag
      else
        writeflag = ESMF_ATTWRITE_TAB
      endif
      
      if (directional == 0) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(comp%compp%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(comp%compp%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 1) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(comp%compp%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(comp%compp%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 2) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(comp%compp%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(comp%compp%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 3) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(comp%compp%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(comp%compp%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      end if

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_CplCompAttWrite

!-------------------------------------------------------------------------
!  GridComp
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridCompAttAddPack"
!BOPI
! !IROUTINE: ESMF_GridCompAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_GridCompAttAddPack(comp, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_GridComp), intent(inout) :: comp  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt comp}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [comp]
!      An {\tt ESMF\_GridComp} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='comp'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'full_name'
      character (len=*), parameter :: name3 = 'version'
      character (len=*), parameter :: name4 = 'discipline'
      character (len=*), parameter :: name5 = 'physical_domain'
      character (len=*), parameter :: name6 = 'agency'
      character (len=*), parameter :: name7 = 'institution'
      character (len=*), parameter :: name8 = 'author'
      character (len=*), parameter :: name9 = 'coding_language'
      character (len=*), parameter :: name10 = 'model_component_framework'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(comp%compp%base, name1, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name2, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name3, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name4, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name5, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name6, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name7, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name8, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name9, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(comp%compp%base, name10, fconvention, &
        fpurpose, fobject, attpacknest, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridCompAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_GridComp, comp, comp%compp%base)
AttRemoveMacro(ESMF_GridComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttGet, ESMF_GridComp, comp, comp%compp%base)
AttGetLogicalMacro(ESMF_GridComp, comp, comp%compp%base)
AttGetCharacterMacro(ESMF_GridComp, comp, comp%compp%base)

GetCountNameNumberMacro(ESMF_GridComp, comp, comp%compp%base)

TypeKind3DeclarationMacro(AttSet, ESMF_GridComp, comp, comp%compp%base)
AttSetLogicalMacro(ESMF_GridComp, comp, comp%compp%base)
AttSetCharacterMacro(ESMF_GridComp, comp, comp%compp%base)

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridCompAttSetLinkCplComp"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link an GridComp Attribute hierarchy to a CplComp
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_GridCompAttSetLinkCplComp(comp1, comp2, rc)
!
! !ARGUMENTS:
      type(ESMF_GridComp), intent(inout) :: comp1
      type(ESMF_CplComp), intent(inout)  :: comp2
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a GridComp to a CplComp in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [comp1]
!      An {\tt ESMF\_GridComp} object.
!     \item [comp2]
!      An {\tt ESMF\_CplComp} object.
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc)

      call ESMF_GridCompValidate(comp1, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      ESMF_INIT_CHECK_DEEP(ESMF_CplCompGetInit,comp2,rc)

      call ESMF_CplCompValidate(comp2, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(comp1%compp%base, comp2%compp%base, &
        localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridCompAttSetLinkCplComp

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridCompAttSetLinkGridComp"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link an GridComp Attribute hierarchy to a GridComp
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_GridCompAttSetLinkGridComp(comp1, comp2, rc)
!
! !ARGUMENTS:
      type(ESMF_GridComp), intent(inout) :: comp1
      type(ESMF_GridComp), intent(inout)  :: comp2
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a GridComp to a GridComp in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [comp1]
!      An {\tt ESMF\_GridComp} object.
!     \item [comp2]
!      An {\tt ESMF\_GridComp} object.
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc)

      call ESMF_GridCompValidate(comp1, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp2,rc)

      call ESMF_GridCompValidate(comp2, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(comp1%compp%base, comp2%compp%base, &
        localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridCompAttSetLinkGridComp

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridCompAttSetLinkState"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link a GridComp Attribute hierarchy to a State
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_GridCompAttSetLinkState(comp1, state, rc)
!
! !ARGUMENTS:
      type(ESMF_GridComp), intent(inout) :: comp1
      type(ESMF_State), intent(inout)  :: state
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a GridComp to a Field in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [comp1]
!      An {\tt ESMF\_GridComp} object.
!     \item [state]
!      An {\tt ESMF\_State} object.
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp1,rc)

      call ESMF_GridCompValidate(comp1, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(comp1%compp%base, state%statep%base, &
        localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridCompAttSetLinkState

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridCompAttUpdate"
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeUpdate()
      subroutine ESMF_GridCompAttUpdate(comp, vm, rootList, rc)
!
! !ARGUMENTS:
      type(ESMF_GridComp), intent(inout) :: comp
      type(ESMF_VM), intent(in) :: vm
      integer, dimension(:), intent(in) :: rootList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Update an Attribute hierarchy.
!
!     The arguments are:
!     \begin{description}
!     \item [comp]
!      An {\tt ESMF\_GridComp} object.
!     \item [vm]
!      The virtural machine over which this Attribute hierarchy 
!      should be updated.
!     \item [rootList]
!      The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, count                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc)

      call ESMF_GridCompValidate(comp, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      count = size(rootList)
      call c_ESMC_AttributeUpdate(comp%compp%base, vm, rootList, count, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridCompAttUpdate

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridCompAttWrite"
!BOPI
! !IROUTINE: ESMF_GridCompAttWrite - Print the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeWrite()
      subroutine ESMF_GridCompAttWrite(comp, convention, purpose, &
        attwriteflag, rc)
!
! !ARGUMENTS:
      type(ESMF_GridComp), intent(inout) :: comp  
      character (len = *), intent(in), optional :: convention
      character (len = *), intent(in), optional :: purpose
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Write the Attribute package for the {\tt comp}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [comp]
!      An {\tt ESMF\_GridComp} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attwriteflag]
!      Flag to determine the format for writing the Attributes.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, directional                           ! Error status
      character(len=*), parameter :: fconvention='N/A'
      character(len=*), parameter :: fpurpose='N/A'
      character(len=*), parameter :: fobject='comp'
      character(len=*), parameter :: ftarobj='field'
      type(ESMF_AttWriteFlag) :: writeflag

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridCompGetInit,comp,rc)

      call ESMF_GridCompValidate(comp, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      directional = 0
      if (present(convention)) then
        directional = 1 ! convention only
      endif
      
      if (present(purpose)) then
        directional = 2 ! purpose only
      endif
      
      if (present(convention) .AND. present(purpose)) then
        directional = 3 ! convention and purpose
      endif

      if (present(attwriteflag)) then
        writeflag = attwriteflag
      else
        writeflag = ESMF_ATTWRITE_TAB
      endif
      
      if (directional == 0) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(comp%compp%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(comp%compp%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 1) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(comp%compp%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(comp%compp%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 2) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(comp%compp%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(comp%compp%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 3) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(comp%compp%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(comp%compp%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      end if

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridCompAttWrite

!-------------------------------------------------------------------------
!  FIELD
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldAttAddPack"
!BOPI
! !IROUTINE: ESMF_FieldAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_FieldAttAddPack(field, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Field), intent(inout) :: field  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt field}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [field]
!      An {\tt ESMF\_Field} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='field'
      character (len=*), parameter :: name1 = 'name'
      character (len=*), parameter :: name2 = 'standard_name'
      character (len=*), parameter :: name3 = 'long_name'
      character (len=*), parameter :: name4 = 'units'
      character (len=*), parameter :: name5 = 'import'
      character (len=*), parameter :: name6 = 'export'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(field%ftypep%base, name1, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(field%ftypep%base, name2, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(field%ftypep%base, name3, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(field%ftypep%base, name4, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(field%ftypep%base, name5, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(field%ftypep%base, name6, fconvention, &
        fpurpose, fobject, attpacknest, localrc)

      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FieldAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_Field, field, field%ftypep%base)
AttRemoveMacro(ESMF_Field, field, field%ftypep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_Field, field, field%ftypep%base)
AttGetLogicalMacro(ESMF_Field, field, field%ftypep%base)
AttGetCharacterMacro(ESMF_Field, field, field%ftypep%base)

GetCountNameNumberMacro(ESMF_Field, field, field%ftypep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_Field, field, field%ftypep%base)
AttSetLogicalMacro(ESMF_Field, field, field%ftypep%base)
AttSetCharacterMacro(ESMF_Field, field, field%ftypep%base)

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldAttUpdate"
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeUpdate()
      subroutine ESMF_FieldAttUpdate(field, vm, rootList, rc)
!
! !ARGUMENTS:
      type(ESMF_Field), intent(inout) :: field
      type(ESMF_VM), intent(in) :: vm
      integer, dimension(:), intent(in) :: rootList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Update an Attribute hierarchy.
!
!     The arguments are:
!     \begin{description}
!     \item [field]
!      An {\tt ESMF\_Field} object.
!     \item [vm]
!      The virtural machine over which this Attribute hierarchy 
!      should be updated.
!     \item [rootList]
!      The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, count                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc)

      ! this is commented out because empty objects can hold Attributes
      !call ESMF_FieldValidate(field, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      count = size(rootList)
      call c_ESMC_AttributeUpdate(field%ftypep%base, vm, rootList, count, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FieldAttUpdate

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FieldAttWrite"
!BOPI
! !IROUTINE: ESMF_AttributeWrite - Print the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeWrite()
      subroutine ESMF_FieldAttWrite(field, convention, purpose, &
        attwriteflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Field), intent(inout) :: field  
      character (len = *), intent(in), optional :: convention
      character (len = *), intent(in), optional :: purpose
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Write the Attribute package for the {\tt field}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [field]
!      An {\tt ESMF\_Field} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attwriteflag]
!      Flag to determine the format for writing the Attributes.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, directional                           ! Error status
      character(len=*), parameter :: fconvention='N/A'
      character(len=*), parameter :: fpurpose='N/A'
      character(len=*), parameter :: fobject='field'
      character(len=*), parameter :: ftarobj='field'
      type(ESMF_AttWriteFlag) :: writeflag

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldGetInit,field,rc)

      call ESMF_FieldValidate(field, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      directional = 0
      if (present(convention)) then
        directional = 1 ! convention only
      endif
      
      if (present(purpose)) then
        directional = 2 ! purpose only
      endif
      
      if (present(convention) .AND. present(purpose)) then
        directional = 3 ! convention and purpose
      endif
      
      if (present(attwriteflag)) then
        writeflag = attwriteflag
      else
        writeflag = ESMF_ATTWRITE_TAB
      endif
      
      if (directional == 0) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(field%ftypep%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(field%ftypep%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 1) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(field%ftypep%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(field%ftypep%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 2) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(field%ftypep%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(field%ftypep%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 3) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(field%ftypep%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(field%ftypep%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      end if

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FieldAttWrite

!-------------------------------------------------------------------------
!  FIELDBUNDLE
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FBundleAttAddPack"
!BOPI
! !IROUTINE: ESMF_FBundleAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_FBundleAttAddPack(fieldbundle, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_FieldBundle), intent(inout) :: fieldbundle  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt fieldbundle}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!      An {\tt ESMF\_FieldBundle} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='fieldbundle'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc)

      fconvention = convention
      fpurpose = purpose
      
       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      ! no standard attribute package for FieldBundle at this time
      localrc = ESMF_SUCCESS

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FBundleAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttRemoveMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttGetLogicalMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttGetCharacterMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

GetCountNameNumberMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttSetLogicalMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)
AttSetCharacterMacro(ESMF_FieldBundle, fieldbundle, fieldbundle%btypep%base)

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FBundleAttSetLinkField"
!BOP
! !IROUTINE: ESMF_AttributeSet - Link a FieldBundle Attribute hierarchy to that 
!                                {\bf of a Field}
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_FBundleAttSetLinkField(fieldbundle, field, rc)
!
! !ARGUMENTS:
      type(ESMF_FieldBundle), intent(inout) :: fieldbundle
      type(ESMF_Field), intent(inout)  :: field
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a FieldBundle to a Field in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!      An {\tt ESMF\_FieldBundle} object.
!     \item [field]
!      An {\tt ESMF\_Field} object.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP

      integer :: localrc                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc)

      call ESMF_FieldBundleValidate(fieldbundle, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(fieldbundle%btypep%base, field%ftypep%base, &
        localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FBundleAttSetLinkField

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FBundleAttUpdate"
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeUpdate()
      subroutine ESMF_FBundleAttUpdate(fieldbundle, vm, rootList, rc)
!
! !ARGUMENTS:
      type(ESMF_FieldBundle), intent(inout) :: fieldbundle
      type(ESMF_VM), intent(in) :: vm
      integer, dimension(:), intent(in) :: rootList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Update an Attribute hierarchy.
!
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!      An {\tt ESMF\_FieldBundle} object.
!     \item [vm]
!      The virtural machine over which this Attribute hierarchy 
!      should be updated.
!     \item [rootList]
!      The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, count                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc)

      !call ESMF_FieldBundleValidate(fieldbundle, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      count = size(rootList)
      call c_ESMC_AttributeUpdate(fieldbundle%btypep%base, vm, rootList, count, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FBundleAttUpdate

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_FBundleAttWrite"
!BOPI
! !IROUTINE: ESMF_FBundleAttWrite - Print the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeWrite()
      subroutine ESMF_FBundleAttWrite(fieldbundle, convention, purpose, &
        attwriteflag, rc)
!
! !ARGUMENTS:
      type(ESMF_FieldBundle), intent(inout) :: fieldbundle  
      character (len = *), intent(in), optional :: convention
      character (len = *), intent(in), optional :: purpose
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Write the Attribute package for the {\tt fieldbundle}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [fieldbundle]
!      An {\tt ESMF\_FieldBundle} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attwriteflag]
!      Flag to determine the format for writing the Attributes.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, directional                           ! Error status
      character(len=*), parameter :: fconvention='N/A'
      character(len=*), parameter :: fpurpose='N/A'
      character(len=*), parameter :: fobject='fieldbundle'
      character(len=*), parameter :: ftarobj='field'
      type(ESMF_AttWriteFlag) :: writeflag

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_FieldBundleGetInit,fieldbundle,rc)

      call ESMF_FieldBundleValidate(fieldbundle, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      directional = 0
      if (present(convention)) then
        directional = 1 ! convention only
      endif
      
      if (present(purpose)) then
        directional = 2 ! purpose only
      endif
      
      if (present(convention) .AND. present(purpose)) then
        directional = 3 ! convention and purpose
      endif

      if (present(attwriteflag)) then
        writeflag = attwriteflag
      else
        writeflag = ESMF_ATTWRITE_TAB
      endif
      
      if (directional == 0) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(fieldbundle%btypep%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(fieldbundle%btypep%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 1) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(fieldbundle%btypep%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(fieldbundle%btypep%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 2) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(fieldbundle%btypep%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(fieldbundle%btypep%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 3) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(fieldbundle%btypep%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(fieldbundle%btypep%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      end if

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_FBundleAttWrite

!-------------------------------------------------------------------------
!  GRID
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridAttAddPack"
!BOPI
! !IROUTINE: ESMF_GridAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_GridAttAddPack(grid, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(inout) :: grid  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt grid}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [grid]
!      An {\tt ESMF\_Grid} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='grid'
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      ! no standard attribute package for Grid at this time
      localrc = ESMF_SUCCESS

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridAttAddPack

!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_Grid, grid, grid)
AttRemoveMacro(ESMF_Grid, grid, grid)

TypeKind3DeclarationMacro(AttGet, ESMF_Grid, grid, grid)
AttGetLogicalMacro(ESMF_Grid, grid, grid)
AttGetCharacterMacro(ESMF_Grid, grid, grid)

GetCountNameNumberMacro(ESMF_Grid, grid, grid)

TypeKind3DeclarationMacro(AttSet, ESMF_Grid, grid, grid)
AttSetLogicalMacro(ESMF_Grid, grid, grid)
AttSetCharacterMacro(ESMF_Grid, grid, grid)

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridAttUpdate"
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeUpdate()
      subroutine ESMF_GridAttUpdate(grid, vm, rootList, rc)
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(inout) :: grid
      type(ESMF_VM), intent(in) :: vm
      integer, dimension(:), intent(in) :: rootList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Update an Attribute hierarchy.
!
!     The arguments are:
!     \begin{description}
!     \item [grid]
!      An {\tt ESMF\_Grid} object.
!     \item [vm]
!      The virtural machine over which this Attribute hierarchy 
!      should be updated.
!     \item [rootList]
!      The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, count                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

      ! this is commented out because empty objects can hold Attributes
      !call ESMF_GridValidate(grid, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      count = size(rootList)
      call c_ESMC_AttributeUpdate(grid, vm, rootList, count, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridAttUpdate

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_GridAttWrite"
!BOPI
! !IROUTINE: ESMF_GridAttWrite - Print the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeWrite()
      subroutine ESMF_GridAttWrite(grid, convention, purpose, &
        attwriteflag, rc)
!
! !ARGUMENTS:
      type(ESMF_Grid), intent(inout) :: grid  
      character (len = *), intent(in), optional :: convention
      character (len = *), intent(in), optional :: purpose
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Write the Attribute package for the {\tt grid}.
!     The Attribute package defines the convention, purpose, and object type
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [grid]
!      An {\tt ESMF\_Grid} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attwriteflag]
!      Flag to determine the format for writing the Attributes.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, directional                           ! Error status
      character(len=*), parameter :: fconvention='N/A'
      character(len=*), parameter :: fpurpose='N/A'
      character(len=*), parameter :: fobject='grid'
      character(len=*), parameter :: ftarobj='grid'
      type(ESMF_AttWriteFlag) :: writeflag

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_GridGetInit,grid,rc)

      directional = 0
      if (present(convention)) then
        directional = 1 ! convention only
      endif
      
      if (present(purpose)) then
        directional = 2 ! purpose only
      endif
      
      if (present(convention) .AND. present(purpose)) then
        directional = 3 ! convention and purpose
      endif

      if (present(attwriteflag)) then
        writeflag = attwriteflag
      else
        writeflag = ESMF_ATTWRITE_TAB
      endif
      
      if (directional == 0) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(grid, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(grid, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 1) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(grid, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(grid, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 2) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(grid, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(grid, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 3) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(grid, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(grid, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      end if

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_GridAttWrite

!-------------------------------------------------------------------------
!  STATE
!-------------------------------------------------------------------------

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateAttAddPack"
!BOPI
! !IROUTINE: ESMF_StateAttAddPack - Create the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeAdd()
      subroutine ESMF_StateAttAddPack(state, convention, purpose, &
        attpacknestflag, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout) :: state  
      character (len = *), intent(in) :: convention
      character (len = *), intent(in) :: purpose
      type(ESMF_AttPackNestFlag), intent(in), optional :: attpacknestflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Sets up the Attribute package for the {\tt state}.
!     The Attribute package defines the convention, purpose, and object type 
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [state]
!      An {\tt ESMF\_State} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attpacknestflag]
!      The flag to tell whether this Attribute package is to be nested or not, possible values
!      are {\bf ESMF\_ATTPACKNEST\_ON} and {\bf ESMF\_ATTPACKNEST\_OFF}.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      character (len=len_trim(convention)) :: fconvention
      character (len=len_trim(purpose)) :: fpurpose
      character (len=*), parameter :: fobject='state'
      character (len=*), parameter :: name1 = 'import'
      character (len=*), parameter :: name2 = 'export'
      type(ESMF_Logical) :: lvalue
      type(ESMF_AttPackNestFlag) :: attpacknest

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

      fconvention = convention
      fpurpose = purpose

       if (present(attpacknestflag)) then
        attpacknest = attpacknestflag
      else
        attpacknest = ESMF_ATTPACKNEST_OFF
      endif

      call c_ESMC_AttPackCreate(state%statep%base, name1, fconvention, &
        fpurpose, fobject, attpacknest, localrc)
      call c_ESMC_AttPackCreate(state%statep%base, name2, fconvention, &
        fpurpose, fobject, attpacknest, localrc)

      lvalue = .true.
      if (state%statep%st == ESMF_STATE_IMPORT) then
        call c_ESMC_AttPackSetValue(state%statep%base, name1, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue, &
          fconvention, fpurpose, fobject, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (state%statep%st == ESMF_STATE_EXPORT) then
        call c_ESMC_AttPackSetValue(state%statep%base, name2, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue, &
          fconvention, fpurpose, fobject, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_StateAttAddPack

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateAttributeCopyAll"
!BOPI
! !IROUTINE: ESMF_StateAttributeCopyAll - Copy an Attribute hierarchy between states
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeCopy()
      subroutine ESMF_StateAttributeCopyAll(state1, state2, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout) :: state1  
      type(ESMF_State), intent(inout) :: state2 
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Copy all Attributes in one {\tt state} hierarchy to another.
!
!     The arguments are:
!     \begin{description}
!     \item [state1]
!      An {\tt ESMF\_State} object.
!     \item [state2]
!      An {\tt ESMF\_State} object.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      
      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc)
      
      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc)

      call ESMF_StateValidate(state1, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return
      
      call ESMF_StateValidate(state2, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
            ESMF_ERR_PASSTHRU, &
            ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeCopyAll(state1%statep%base, state2%statep%base, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_StateAttributeCopyAll


!------------------------------------------------------------------------------

AttAddPackCustomMacro(ESMF_State, state, state%statep%base)
AttRemoveMacro(ESMF_State, state, state%statep%base)

TypeKind3DeclarationMacro(AttGet, ESMF_State, state, state%statep%base)
AttGetLogicalMacro(ESMF_State, state, state%statep%base)
AttGetCharacterMacro(ESMF_State, state, state%statep%base)

GetCountNameNumberMacro(ESMF_State, state, state%statep%base)

TypeKind3DeclarationMacro(AttSet, ESMF_State, state, state%statep%base)
AttSetLogicalMacro(ESMF_State, state, state%statep%base)
AttSetCharacterMacro(ESMF_State, state, state%statep%base)

!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeSet - Link a State Attribute hierarchy with the
!                               {\bf hierarchy of a FieldBundle, Field, or State}
!
! !INTERFACE:
!      ! Private name; call using ESMF_AttributeSet()
!      subroutine ESMF_StateAttributeSetLink(state, <object>, rc)
!
! !ARGUMENTS:
!      type(ESMF\_State), intent(inout) :: state  
!      <object>, see below for supported values
!      integer, intent(out), optional :: rc   
!
!
! !DESCRIPTION:
!     Attaches a {\tt State} Attribute hierarchy to the hierarchy of
!     a {\tt Fieldbundle}, {\tt Field}, or another {\tt State}. 
!     Supported values for the <object> are:
!     \begin{description}
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle
!     \item type(ESMF\_Field), intent(inout) :: field
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
! 
!     The arguments are:
!     \begin{description}
!     \item [state]
!       An {\tt ESMF\_State} object.
!     \item [<object>]
!       The object with which to link hierarchies.
!     \item [{[rc]}] 
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateAttSetLinkFB"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link a State to a FieldBundle in an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_StateAttSetLinkFB(state, bundle, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout) :: state
      type(ESMF_FieldBundle), intent(inout)  :: bundle
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a State to a FieldBundle in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [state]
!      An {\tt ESMF\_State} object.
!     \item [bundle]
!      An {\tt ESMF\_FieldBundle} object.
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      type(ESMF_Logical) :: lvalue1, lvalue2
      character (len=*), parameter :: lobject = 'field'
      character (len=*), parameter :: lname1 = 'import'
      character (len=*), parameter :: lname2 = 'export'

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

      call ESMF_StateValidate(state, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(state%statep%base, bundle%btypep%base, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      ! set the import and export Attributes on any Field connected to this State
      lvalue1 = .true.
      lvalue2 = .false.
      if (state%statep%st == ESMF_STATE_IMPORT) then
        call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc)
        call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (state%statep%st == ESMF_STATE_EXPORT) then
        call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc)
        call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      
      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_StateAttSetLinkFB

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateAttSetLinkField"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link a State to a Field in an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_StateAttSetLinkField(state, field, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout) :: state
      type(ESMF_Field), intent(inout)  :: field
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a State to a Field in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [state]
!      An {\tt ESMF\_State} object.
!     \item [field]
!      An {\tt ESMF\_Field} object.
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      type(ESMF_Logical) :: lvalue1, lvalue2
      character (len=*), parameter :: lobject = 'field'
      character (len=*), parameter :: lname1 = 'import'
      character (len=*), parameter :: lname2 = 'export'

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

      call ESMF_StateValidate(state, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(state%statep%base, field%ftypep%base, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      ! set the import and export Attributes on any Field connected to this State
      lvalue1 = .true.
      lvalue2 = .false.
      if (state%statep%st == ESMF_STATE_IMPORT) then
        call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc)
        call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (state%statep%st == ESMF_STATE_EXPORT) then
        call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname1, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc)
        call c_ESMC_AttributeSetObjsInTree(state%statep%base, lobject, lname2, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      
      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_StateAttSetLinkField

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateAttSetLinkState"
!BOPI
! !IROUTINE: ESMF_AttributeSet - Link a State to a State in an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeSet()
      subroutine ESMF_StateAttSetLinkState(state1, state2, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout) :: state1
      type(ESMF_State), intent(inout)  :: state2
      integer, intent(out), optional  :: rc   

!
! !DESCRIPTION:
!     Attaches a State to a State in an Attribute hierarchy
!
!     The arguments are:
!     \begin{description}
!     \item [state1]
!      An {\tt ESMF\_State} object.
!     \item [state2]
!      An {\tt ESMF\_State} object.
!       Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc                           ! Error status
      type(ESMF_Logical) :: lvalue1, lvalue2
      character (len=*), parameter :: lobject = 'field'
      character (len=*), parameter :: lname1 = 'import'
      character (len=*), parameter :: lname2 = 'export'

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state1,rc)
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state2,rc)

      call ESMF_StateValidate(state1, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return
                                  
      call ESMF_StateValidate(state2, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      call c_ESMC_AttributeSetLink(state1%statep%base, state2%statep%base, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      ! set the import and export Attributes on any Field connected to this State
      lvalue1 = .true.
      lvalue2 = .false.
      if (state1%statep%st == ESMF_STATE_IMPORT) then
        call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname1, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc)
        call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname2, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (state1%statep%st == ESMF_STATE_EXPORT) then
        call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname1, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue2, localrc)
        call c_ESMC_AttributeSetObjsInTree(state1%statep%base, lobject, lname2, &
          ESMF_TYPEKIND_LOGICAL, 1, lvalue1, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      
      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_StateAttSetLinkState

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateAttUpdate"
!BOPI
! !IROUTINE: ESMF_AttributeUpdate - Update an Attribute hierarchy
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeUpdate()
      subroutine ESMF_StateAttUpdate(state, vm, rootList, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout) :: state
      type(ESMF_VM), intent(in) :: vm
      integer, dimension(:), intent(in) :: rootList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Update an Attribute hierarchy.
!
!     The arguments are:
!     \begin{description}
!     \item [state]
!      An {\tt ESMF\_State} object.
!     \item [vm]
!      The virtural machine over which this Attribute hierarchy 
!      should be updated.
!     \item [rootList]
!      The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, count                           ! Error status

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

      call ESMF_StateValidate(state, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      count = size(rootList)
      call c_ESMC_AttributeUpdate(state%statep%base, vm, rootList, count, localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_StateAttUpdate

!------------------------------------------------------------------------------
^undef  ESMF_METHOD
^define ESMF_METHOD "ESMF_StateAttWrite"
!BOPI
! !IROUTINE: ESMF_StateAttWrite - Print the Attribute package
!
! !INTERFACE:
      ! Private name; call using ESMF_AttributeWrite()
      subroutine ESMF_StateAttWrite(state, convention, purpose, &
        attwriteflag, rc)
!
! !ARGUMENTS:
      type(ESMF_State), intent(inout) :: state  
      character (len = *), intent(in), optional :: convention
      character (len = *), intent(in), optional :: purpose
      type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Write the Attribute package for the {\tt state}.
!     The Attribute package defines the convention, purpose, and object type 
!     of the associated Attributes.
!
!     The arguments are:
!     \begin{description}
!     \item [state]
!      An {\tt ESMF\_State} object.
!     \item [convention]
!      The convention of the Attribute package.
!     \item [purpose]
!      The purpose of the Attribute package.
!     \item [attwriteflag]
!      Flag to determine the format for writing the Attributes.
!     \item [{[rc]}] 
!      Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: localrc, directional                           ! Error status
      character(len=*), parameter :: fconvention='N/A'
      character(len=*), parameter :: fpurpose='N/A'
      character(len=*), parameter :: fobject='state'
      character(len=*), parameter :: ftarobj='field'
      type(ESMF_AttWriteFlag) :: writeflag

      ! Initialize return code; assume failure until success is certain
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! check input variables
      ESMF_INIT_CHECK_DEEP(ESMF_StateGetInit,state,rc)

      call ESMF_StateValidate(state, rc=localrc)
      if (ESMF_LogMsgFoundError(localrc, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      directional = 0
      if (present(convention)) then
        directional = 1 ! convention only
      endif
      
      if (present(purpose)) then
        directional = 2 ! purpose only
      endif
      
      if (present(convention) .AND. present(purpose)) then
        directional = 3 ! convention and purpose
      endif

      if (present(attwriteflag)) then
        writeflag = attwriteflag
      else
        writeflag = ESMF_ATTWRITE_TAB
      endif
      
      if (directional == 0) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(state%statep%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(state%statep%base, fconvention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 1) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(state%statep%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(state%statep%base, convention, &
          fpurpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 2) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(state%statep%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(state%statep%base, fconvention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      else if (directional == 3) then
      if (writeflag%value .eq. ESMF_ATTWRITE_TAB%value) then
        call c_ESMC_AttributeWriteTab(state%statep%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      else if (writeflag%value .eq. ESMF_ATTWRITE_XML%value) then
        call c_ESMC_AttributeWriteXML(state%statep%base, convention, &
          purpose, fobject, ftarobj, localrc)
        if (ESMF_LogMsgFoundError(localrc, &
                                ESMF_ERR_PASSTHRU, &
                                ESMF_CONTEXT, rc)) return
      endif
      end if

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_StateAttWrite
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeUpdate  - Update an Attribute hierarchy
!
! !INTERFACE:
!     subroutine ESMF_AttributeUpdate(<object>, vm, rootList, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     type(ESMF_VM), intent(in) :: vm
!     integer, dimension(:), intent(in) :: rootList
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Update an Attribute hierarchy during runtime.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [vm]
!           The virtural machine over which this Attribute hierarchy 
!           should be updated.
!     \item [rootList]
!           The list of "root" PETs that are to be used to update.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOP
!------------------------------------------------------------------------------
!BOP
! !IROUTINE: ESMF_AttributeWrite  - Write an Attribute package
!
! !INTERFACE:
!     subroutine ESMF_AttributeWrite(<object>, convention, purpose, attwriteflag, rc)
!
! !ARGUMENTS:
!     <object>, see below for supported values  
!     character (len = *), intent(in), optional :: convention
!     character (len = *), intent(in), optional :: purpose
!     type(ESMF_AttWriteFlag), intent(in), optional :: attwriteflag
!     integer, intent(out), optional :: rc   
!
! !DESCRIPTION:
!     Write the Attribute package for <object>.  The Attribute package defines 
!     the convention, purpose, and object type of the associated Attributes.  Either
!     tab-delimited or xml format is acheived by using {\tt attwriteflag}.
!     Supported values for <object> are:
!     \begin{description}
!     \item type(ESMF\_Array), intent(inout) :: array
!     \item type(ESMF\_CplComp), intent(inout) :: comp  
!     \item type(ESMF\_GridComp), intent(inout) :: comp  
!     \item type(ESMF\_Field), intent(inout) :: field  
!     \item type(ESMF\_FieldBundle), intent(inout) :: fbundle 
!     \item type(ESMF\_Grid), intent(inout) :: grid
!     \item type(ESMF\_State), intent(inout) :: state
!     \end{description}
!
!     The arguments are:
!     \begin{description}
!     \item [<object>]
!           An {\tt ESMF} object.
!     \item [convention]
!           The convention of the Attribute package.
!     \item [purpose]
!           The purpose of the Attribute package.
!     \item [attwriteflag]
!           The flag to specify which format is desired for the write, the 
!           default is tab-delimited.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!     NOTE:  The options for {\tt attwriteflag} include:
!            \begin{enumerate}
!              \item ESMF\_ATTWRITE\_XML will write in xml format
!              \item ESMF\_ATTWRITE\_TAB will write in tab-delimited format
!            \end{enumerate}
!
!EOP
!------------------------------------------------------------------------------

end module ESMF_AttributeMod
