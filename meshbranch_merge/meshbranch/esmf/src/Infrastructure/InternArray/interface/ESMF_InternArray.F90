! $Id: ESMF_InternArray.F90,v 1.29 2009/01/21 21:37:59 cdeluca Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2009, University Corporation for Atmospheric Research, 
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics 
! Laboratory, University of Michigan, National Centers for Environmental 
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory, 
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!==============================================================================
#define ESMF_FILENAME "ESMF_InternArray.F90"
!==============================================================================
!
! ESMF InternArray module
module ESMF_InternArrayMod
!
!==============================================================================
!
! This file contains the Array class definition and all Array
! class methods which are *not* generated by macro.  
! See ESMF_InternArrayCreate.F90 and ESMF_InternArrayGet.F90 for the 
! macro-generated interfaces.
!
!------------------------------------------------------------------------------
! INCLUDES
#include "ESMF.h"

!==============================================================================
!BOPI
! !MODULE: ESMF_InternArrayMod - Manage data arrays uniformly between F90 and C++     
!
! !DESCRIPTION:
!
! The code in this file implements the {\tt Array} class and 
!  associated functions and subroutines.  
!
! C and C++ arrays are simple pointers to memory.
! Fortran arrays contain shape and stride definitions and are strongly
! typed.  To enable interoperability between the languages the C++ code
! must be able to obtain this information from the Fortran description
! (which is called the "dope vector" in Fortran), either through a priori
! knowledge or through query.
!
!------------------------------------------------------------------------------
! !USES:
  use ESMF_UtilTypesMod     ! ESMF utility types
  use ESMF_InitMacrosMod    ! ESMF initializer macros
  use ESMF_BaseMod          ! ESMF base class
  use ESMF_LogErrMod        ! ESMF error handling
  use ESMF_IOSpecMod
  use ESMF_ArraySpecMod
  use ESMF_LocalArrayMod
  use ESMF_DELayoutMod
  
  implicit none

!------------------------------------------------------------------------------
! !PRIVATE TYPES:
  private
!------------------------------------------------------------------------------
  ! ESMF_HaloDirection
 
  ! Object for specifiying halo directions (mostly a placeholder for now)

  type ESMF_HaloDirection
  sequence
  private
    integer :: edges
    ESMF_INIT_DECLARE
  end type


!------------------------------------------------------------------------------
  ! ESMF_Mask
 
  ! Class for storing information about masked regions.

  type ESMF_Mask
  sequence
  private
    type (ESMF_LocalArray), pointer :: maskvals 
    ESMF_INIT_DECLARE
  end type


!------------------------------------------------------------------------------
  ! ESMF_InternArray

  ! Array data type.  All information is kept on the C++ side inside
  ! the class structure.

  type ESMF_InternArray
  sequence
    type(ESMF_Pointer) :: this
    ESMF_INIT_DECLARE
  end type

!------------------------------------------------------------------------------
! !PUBLIC TYPES:
  public ESMF_HaloDirection
  public ESMF_Mask
  public ESMF_InternArray
!------------------------------------------------------------------------------

! !PUBLIC MEMBER FUNCTIONS:
 
! - ESMF-public methods:
  public ESMF_InternArrayGet, ESMF_InternArraySet
  public ESMF_IArrayAttributeGet
  public ESMF_IArrayAttributeSet
  public ESMF_IArrayAttributeGetCount
  public ESMF_IArrayAttributeGetInfo

  public ESMF_IArraySetAxisIndex, ESMF_IArrayGetAxisIndex  
  !public ESMF_IArrayComputeAxisIndex

  public ESMF_InternArrayWriteRestart
  public ESMF_InternArrayReadRestart
  public ESMF_InternArrayWrite
  public ESMF_InternArrayRead
 
  public ESMF_InternArrayValidate
  public ESMF_InternArrayPrint
!EOPI

! - ESMF-internal methods:
  public ESMF_InternArrayGetInit
  public ESMF_InternArraySetInitCreated

  public ESMF_HaloDirectionInit
  public ESMF_HaloDirectionGetInit
  
  public ESMF_MaskInit
  public ESMF_MaskGetInit

  public assignment(=)

!------------------------------------------------------------------------------
! The following line turns the CVS identifier string into a printable variable.
  character(*), parameter, private :: version = &
    '$Id: ESMF_InternArray.F90,v 1.29 2009/01/21 21:37:59 cdeluca Exp $'
!
!==============================================================================
!
! INTERFACE BLOCKS
!
!==============================================================================

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_IArrayGetAxisIndex  - Get Array attributes
!
! !INTERFACE:
      interface ESMF_IArrayGetAxisIndex 
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_IArrayGetAxisIndex
        module procedure ESMF_IArrayGetAxisIndexOld

! !DESCRIPTION:
!     This interface provides a single entry point for methods that get
!     AxisIndex derived types from an {\tt ESMF\_Array}.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet  - Set Array attributes
!
! !INTERFACE:
      interface ESMF_IArrayAttributeSet 
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_IArrayAttrSetInt4
        module procedure ESMF_IArrayAttrSetInt4List
        module procedure ESMF_IArrayAttrSetInt8
        module procedure ESMF_IArrayAttrSetInt8List
        module procedure ESMF_IArrayAttrSetReal4
        module procedure ESMF_IArrayAttrSetReal4List
        module procedure ESMF_IArrayAttrSetReal8
        module procedure ESMF_IArrayAttrSetReal8List
        module procedure ESMF_IArrayAttrSetLogical
        module procedure ESMF_IArrayAttrSetLogicalList
        module procedure ESMF_IArrayAttrSetChar

! !DESCRIPTION:
!     This interface provides a single entry point for methods that attach
!     attributes to an {\tt ESMF\_Array}.
 
!EOPI
      end interface
!
!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet  - Get Array attributes
!
! !INTERFACE:
      interface ESMF_IArrayAttributeGet
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_IArrayAttrGetInt4
        module procedure ESMF_IArrayAttrGetInt4List
        module procedure ESMF_IArrayAttrGetInt8
        module procedure ESMF_IArrayAttrGetInt8List
        module procedure ESMF_IArrayAttrGetReal4
        module procedure ESMF_IArrayAttrGetReal4List
        module procedure ESMF_IArrayAttrGetReal8
        module procedure ESMF_IArrayAttrGetReal8List
        module procedure ESMF_IArrayAttrGetLogical
        module procedure ESMF_IArrayAttrGetLogicalList
        module procedure ESMF_IArrayAttrGetChar

! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     attributes from an {\tt ESMF\_Array}.
 
!EOPI
      end interface

!------------------------------------------------------------------------------
!BOPI
! !IROUTINE: ESMF_IArrayAttributeGetInfo - Get type, count from a Array attribute
!
! !INTERFACE:
      interface ESMF_IArrayAttributeGetInfo
   
! !PRIVATE MEMBER FUNCTIONS:
        module procedure ESMF_IArrayAttrGetInfoByName
        module procedure ESMF_IArrayAttrGetInfoByNum

! !DESCRIPTION:
!     This interface provides a single entry point for methods that retrieve
!     information about attributes from an {\tt ESMF\_Array}.
 
!EOPI
      end interface



interface assignment (=)
 module procedure ESMF_aras
end interface

!==============================================================================

      contains

!==============================================================================

subroutine ESMF_aras(daval, saval)
 type(ESMF_LocalArray), intent(out) :: daval
 type(ESMF_InternArray), intent(in) :: saval

 daval%this%ptr = saval%this%ptr

 ESMF_INIT_COPY(daval,saval)

end subroutine


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetInt4"

!BOPI	
! !IROUTINE: ESMF_IArrayAttributeGet  - Retrieve a 4-byte integer attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetInt4(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I4), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Returns an integer attribute from the {\tt array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The integer value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

      ! Initialize return code; assume routine not implemented
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_I4, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetInt4

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetInt4List"

!BOPI	
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve a 4-byte integer list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetInt4List(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      integer(ESMF_KIND_I4), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a 4-byte integer list attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The integer values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

      ! Initialize return code; assume routine not implemented
      if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_I4, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetInt4List

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetInt8"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet  - Retrieve an 8-byte integer attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetInt8(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I8), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Returns an 8-byte integer attribute from the {\tt array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The integer value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_I8, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetInt8

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetInt8List"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve an 8-byte integer list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetInt8List(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      integer(ESMF_KIND_I8), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns an 8-byte integer list attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The integer values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_I8, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetInt8List

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetReal4"

!BOPI	
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve a 4-byte real attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetReal4(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      real(ESMF_KIND_R4), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a 4-byte real attribute from the {\tt array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The real value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_R4, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetReal4

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetReal4List"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve a 4-byte real list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetReal4List(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      real(ESMF_KIND_R4), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a 4-byte real attribute from an {\tt ESMF\_Array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The real values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_R4, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetReal4List

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetReal8"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve an 8-byte real attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetReal8(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      real(ESMF_KIND_R8), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns an 8-byte real attribute from the {\tt array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The real value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_R8, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetReal8

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetReal8List"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve an 8-byte real list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetReal8List(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      real(ESMF_KIND_R8), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns an 8-byte real attribute from an {\tt ESMF\_Array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The real values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_R8, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetReal8List

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetLogical"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve a logical attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetLogical(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      type(ESMF_Logical), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a logical attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The logical value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_LOGICAL, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetLogical

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetLogicalList"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve a logical list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetLogicalList(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      type(ESMF_Logical), dimension(:), intent(out) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a logical list attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [count]
!           The number of values in the attribute.
!     \item [valueList]
!           The logical values of the named attribute.
!           The list must be at least {\tt count} items long.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                    "count longer than valueList", &
                                     ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeGetValue(array%this, name, &
        ESMF_TYPEKIND_LOGICAL, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetLogicalList

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetChar"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGet - Retrieve a character attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGet()
      subroutine ESMF_IArrayAttrGetChar(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      character (len = *), intent(out) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns a character attribute from the {\tt array}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to retrieve.
!     \item [value]
!           The character value of the named attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetChar(array%this, name, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetChar


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttributeGetCount"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGetCount - Query the number of attributes
!
! !INTERFACE:
      subroutine ESMF_IArrayAttributeGetCount(array, count, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      integer, intent(out) :: count   
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Returns the number of attributes associated with the given {\tt array} 
!     in the argument {\tt count}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [count]
!           The number of attributes associated with this object.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetCount(array%this, count, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttributeGetCount

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetInfoByName"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGetInfo - Query Array attributes by name
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGetInfo()
      subroutine ESMF_IArrayAttrGetInfoByName(array, name, typekind, count, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character(len=*), intent(in) :: name
      type(ESMF_TypeKind), intent(out), optional :: typekind
      integer, intent(out), optional :: count   
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Returns information associated with the named attribute, 
!     including {\tt typekind} and {\tt count}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to query.
!     \item [{[typekind]}]
!           The typekind of the attribute.
!     \item [{[count]}]
!           The number of items in this attribute.  For character types,
!           the length of the character string.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      type(ESMF_TypeKind) :: localTk
      integer :: localCount

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetInfoName(array%this, name, &
        localTk, localCount, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(typekind)) typekind = localTk
      if (present(count)) count = localCount

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetInfoByName

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrGetInfoByNum"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeGetInfo - Query Array attributes by index number
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeGetInfo()
      subroutine ESMF_IArrayAttrGetInfoByNum(array, attributeIndex, name, &
        typekind, count, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      integer, intent(in) :: attributeIndex
      character(len=*), intent(out), optional :: name
      type(ESMF_TypeKind), intent(out), optional :: typekind
      integer, intent(out), optional :: count   
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Returns information associated with the indexed attribute, 
!      including {\tt name}, {\tt typekind} and {\tt count}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [attributeIndex]
!           The index number of the attribute to query.
!     \item [name]
!           Returns the name of the attribute.
!     \item [{[typekind]}]
!           The typekind of the attribute.
!     \item [{[count]}]
!           Returns the number of items in this attribute.  For character types,
!           this is the length of the character string.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      character(len=ESMF_MAXSTR) :: localName
      type(ESMF_TypeKind) :: localTk
      integer :: localCount

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeGetInfoNum(array%this, attributeIndex, &
        localName, localTk, localCount, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(name)) name = localName
      if (present(typekind)) typekind = localTk
      if (present(count)) count = localCount

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrGetInfoByNum

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetInt4"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set a 4-byte integer attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetInt4(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(inout) :: array  
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I4), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches a 4-byte integer attribute to the {\tt array}.
!      The attribute has a {\tt name} and a {\tt value}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The integer value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_I4, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetInt4

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetInt4List"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set a 4-byte integer list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetInt4List(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      integer(ESMF_KIND_I4), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches a 4-byte integer list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of integer items in the {\tt valueList} is
!     given by {\tt count}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of integers in the {\tt valueList}.
!     \item [valueList]
!           The integer values of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_I4, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetInt4List

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetInt8"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set an 8-byte integer attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetInt8(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(inout) :: array  
      character (len = *), intent(in) :: name
      integer(ESMF_KIND_I8), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches an 8-byte integer attribute to the {\tt array}.
!      The attribute has a {\tt name} and a {\tt value}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The integer value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

       ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

     call c_ESMC_AttributeSetValue(array%this, name, &
       ESMF_TYPEKIND_I8, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetInt8

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetInt8List"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set an 8-byte integer list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetInt8List(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      integer(ESMF_KIND_I8), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches an 8-byte integer list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of integer items in the {\tt valueList} is
!     given by {\tt count}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of integers in the {\tt valueList}.
!     \item [valueList]
!           The integer values of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_I8, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetInt8List

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetReal4"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set a 4-byte real attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetReal4(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      real(ESMF_KIND_R4), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches a 4-byte real attribute to the {\tt array}.
!      The attribute has a {\tt name} and a {\tt value}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The real value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_R4, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetReal4

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetReal4List"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set a 4-byte real list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetReal4List(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      real(ESMF_KIND_R4), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches a 4-byte real list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of real items in the {\tt valueList} is
!     given by {\tt count}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of reals in the {\tt valueList}.
!     \item [value]
!           The real values of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_R4, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetReal4List

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetReal8"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set an 8-byte real attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetReal8(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      real(ESMF_KIND_R8), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches an 8-byte real attribute to the {\tt array}.
!      The attribute has a {\tt name} and a {\tt value}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The real value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_R8, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetReal8

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetReal8List"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set an 8-byte real list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetReal8List(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      real(ESMF_KIND_R8), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches an 8-byte real list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of real items in the {\tt valueList} is
!     given by {\tt count}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of reals in the {\tt valueList}.
!     \item [value]
!           The real values of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_R8, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetReal8List

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetLogical"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set a logical attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetLogical(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      type(ESMF_Logical), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches a logical attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt value}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The logical true/false value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_LOGICAL, 1, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetLogical

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetLogicalList"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set a logical list attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetLogicalList(array, name, count, valueList, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      integer, intent(in) :: count   
      type(ESMF_Logical), dimension(:), intent(in) :: valueList
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!     Attaches a logical list attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt valueList}.
!     The number of logical items in the {\tt valueList} is
!     given by {\tt count}.
! 
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [count]
!           The number of logicals in the {\tt valueList}.
!     \item [value]
!           The logical true/false values of the attribute.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status
      integer :: limit

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      limit = size(valueList)
      if (count > limit) then
          if (ESMF_LogMsgFoundError(ESMF_RC_OBJ_BAD, &
                                "count longer than valueList", &
                                 ESMF_CONTEXT, rc)) return
      endif

      call c_ESMC_AttributeSetValue(array%this, name, &
        ESMF_TYPEKIND_LOGICAL, count, valueList, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetLogicalList

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayAttrSetChar"

!BOPI
! !IROUTINE: ESMF_IArrayAttributeSet - Set a character attribute
!
! !INTERFACE:
      ! Private name; call using ESMF_IArrayAttributeSet()
      subroutine ESMF_IArrayAttrSetChar(array, name, value, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array  
      character (len = *), intent(in) :: name
      character (len = *), intent(in) :: value
      integer, intent(out), optional :: rc   

!
! !DESCRIPTION:
!      Attaches a character attribute to the {\tt array}.
!     The attribute has a {\tt name} and a {\tt value}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array} object.
!     \item [name]
!           The name of the attribute to add.
!     \item [value]
!           The character value of the attribute to add.
!     \item [{[rc]}] 
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

      integer :: status                           ! Error status

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      call c_ESMC_AttributeSetChar(array%this, name, value, status)
      if (ESMF_LogMsgFoundError(status, &
                                  ESMF_ERR_PASSTHRU, &
                                  ESMF_CONTEXT, rc)) return

      if (present(rc)) rc = ESMF_SUCCESS

      end subroutine ESMF_IArrayAttrSetChar

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArrayGet"
!BOPI
! !IROUTINE: ESMF_InternArrayGet
!
! !INTERFACE:
      subroutine ESMF_InternArrayGet(array, rank, typekind, counts, &
                               lbounds, ubounds, strides, haloWidth, &
                               base, name, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array
      integer, intent(out), optional :: rank
      type(ESMF_TypeKind), intent(out), optional :: typekind
      integer, dimension(:), intent(out), optional :: counts
      integer, dimension(:), intent(out), optional :: lbounds
      integer, dimension(:), intent(out), optional :: ubounds
      integer, dimension(:), intent(out), optional :: strides
      integer, intent(out), optional :: haloWidth
      type(ESMF_Pointer), intent(out), optional :: base
      character(len=ESMF_MAXSTR), intent(out), optional :: name
      integer, intent(out), optional :: rc             

!
! !DESCRIPTION:
!  Return information about an {\tt ESMF\_Array}.
!  For queries where the caller only wants a single value, 
!  specify the argument by name.
!  All the arguments after the array input are optional to facilitate this.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[rank]}]
!           The number of dimensions in the {\tt array}.
!     \item [{[typekind]}]
!           {\tt ESMF\_TypeKind} variable which indicates 
!           the item size in bytes.  See section \ref{opt:typekind}
!           for valid values.
!     \item [{[counts]}]
!           The number of items in each dimension of the {\tt array}.
!     \item [{[lbounds]}]
!           The lower index value of each dimension of the {\tt array}.
!     \item [{[ubounds]}]
!           The upper index value of each dimension of the {\tt array}.
!     \item [{[strides]}]
!           If nonzero, the spacing between index values per dimension
!           of the {\tt array}.
!     \item [{[haloWidth]}]
!           Width of halo region.
!     \item [{[base]}]
!           Base memory address of the data region of the {\tt array}.
!     \item [{[name]}]
!           {\tt array} name.  If one was not specified at create time,
!           a unique name will have been generated.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

      integer :: status      ! Error status
      logical :: rcpresent   ! Return code present
      integer :: lrank       ! Local use to get rank

      ! Initialize return code; assume routine not implemented
      status = ESMF_RC_NOT_IMPL
      rcpresent = .FALSE.
      if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_RC_NOT_IMPL
      endif

      ! Check init status of arguments
!      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      if (present(rank)) then
         call c_ESMC_IArrayGetRank(array, rank, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(typekind)) then
         call c_ESMC_IArrayGetTypeKind(array, typekind, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(counts)) then
         call c_ESMC_IArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_IArrayGetLengths(array, lrank, counts, status)
         if (status .ne. ESMF_SUCCESS) return
      endif

      if (present(lbounds)) then
         call c_ESMC_IArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_IArrayGetLbounds(array, lrank, lbounds, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(ubounds)) then
         call c_ESMC_IArrayGetRank(array, lrank, status)
         if (status .ne. ESMF_SUCCESS) return
         call c_ESMC_IArrayGetUbounds(array, lrank, ubounds, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(haloWidth)) then
         call c_ESMC_IArrayGetHWidth(array, haloWidth, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(base)) then
         call c_ESMC_IArrayGetBaseAddr(array, base, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (present(strides)) then
         call ESMF_LogWrite("Strides not yet supported", &
                               ESMF_LOG_WARNING, ESMF_CONTEXT)
         strides(:) = 1
      endif

      if (present(name)) then
         call c_ESMC_GetName(array, name, status)
         if (status .ne. ESMF_SUCCESS) return
      endif
   
      if (rcpresent) rc = ESMF_SUCCESS

      end subroutine ESMF_InternArrayGet


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayGetAxisIndex"
!BOPI
! !IROUTINE: ESMF_IArrayGetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_IArrayGetAxisIndex(array, domainTypeFlag, AIPerRank, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array 
      type(ESMF_DomainTypeFlag), intent(in) :: domainTypeFlag
      type(ESMF_AxisIndex), intent(inout) :: AIPerRank(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to retrieve the index annotation from an {\tt ESMF\_Array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [domainTypeFlag]
!     \item [AIPerRank]
!           An array of index spaces.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

        integer :: status, i

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

        ! Check init status of arguments
!        ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

        ! call c routine to get index
        call c_ESMC_IArrayGetAxisIndex(array, domainTypeFlag, AIPerRank,&
                                      status)
        if (status .ne. ESMF_SUCCESS) goto 10

        ! translate from C++ to Fortran
        do i=1,size(AIPerRank)
          AIPerRank(i)%min = AIPerRank(i)%min + 1
          AIPerRank(i)%max = AIPerRank(i)%max + 1
        enddo

        status = ESMF_SUCCESS

 10     continue

        if (present(rc)) rc = status

        end subroutine ESMF_IArrayGetAxisIndex

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArrayGetAxisIndex"
!BOPI
! !IROUTINE: ESMF_IArrayGetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_IArrayGetAxisIndexOld(array, totalindex, compindex, &
                                           exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array 
      type(ESMF_AxisIndex), intent(inout), optional :: totalindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: compindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: exclindex(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to retrieve the index annotation from an {\tt ESMF\_Array}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [totalindex]
!           An array of index spaces for the total array size.
!     \item [{[compindex]}]
!           An array of index spaces for the computational array size.
!     \item [{[exclindex]}]
!           An array of index spaces for the exclusive array size.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

        integer :: status, i

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

        ! Check init status of arguments
        ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

        ! call c routine to get index
        if (present(totalindex)) then
          call c_ESMC_IArrayGetAxisIndex(array, ESMF_DOMAIN_TOTAL, totalindex,&
                                        status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min + 1
            totalindex(i)%max = totalindex(i)%max + 1
          enddo
        endif

        if (present(compindex)) then
          call c_ESMC_IArrayGetAxisIndex(array, ESMF_DOMAIN_COMPUTATIONAL, &
                                        compindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min + 1
            compindex(i)%max = compindex(i)%max + 1
          enddo
        endif

        if (present(exclindex)) then
          call c_ESMC_IArrayGetAxisIndex(array, ESMF_DOMAIN_EXCLUSIVE, &
                                        exclindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min + 1
            exclindex(i)%max = exclindex(i)%max + 1
          enddo
        endif

        status = ESMF_SUCCESS

 10   continue
        if (present(rc)) rc = status

        end subroutine ESMF_IArrayGetAxisIndexOld

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InterArrayPrint"
!BOPI
! !IROUTINE: ESMF_InternArrayPrint - Print contents of an Array object
!
! !INTERFACE:
      subroutine ESMF_InternArrayPrint(array, options, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in) :: array
      character (len = *), intent(in), optional :: options
      integer, intent(out), optional :: rc 
!
! !DESCRIPTION:
!     Prints information about the {\tt array} to {\tt stdout}. \\
!
!     Note:  Many {\tt ESMF\_<class>Print} methods are implemented in C++.
!     On some platforms/compilers there is a potential issue with interleaving
!     Fortran and C++ output to {\tt stdout} such that it doesn't appear in
!     the expected order.  If this occurs, it is recommended to use the
!     standard Fortran call {\tt flush(6)} as a workaround until this issue
!     is fixed in a future release. \\
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[options]}]
!           Print options are not yet supported.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

       character (len=6) :: defaultopts      ! default print options 
       integer :: status                     ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume routine not implemented
       status = ESMF_RC_NOT_IMPL
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_RC_NOT_IMPL
       endif

        ! Check init status of arguments
        ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

       defaultopts = "brief"

       if(present(options)) then
           call c_ESMC_IArrayPrint(array, options, status) 
       else
           call c_ESMC_IArrayPrint(array, defaultopts, status) 
       endif

       if (ESMF_LogMsgFoundError(status, &
                                    ESMF_ERR_PASSTHRU, &
                                    ESMF_CONTEXT, rc)) return

       ! set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_InternArrayPrint

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArrayRead"
!BOPI
! !IROUTINE: ESMF_InternArrayRead
!
! !INTERFACE:
      function ESMF_InternArrayRead(name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_InternArray) :: ESMF_InternArrayRead
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name              ! array name to read
      type(ESMF_IOSpec), intent(in), optional :: iospec    ! file specs
      integer, intent(out), optional :: rc                 ! return code
!
! !DESCRIPTION:
!     Read data from persistent storage in a variety of formats.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

!
!	Changed BOP/EOP to BOPI/EOPI until function is implemented.
!
        type (ESMF_InternArray) :: a

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

!       ! this is just to prevent compiler warnings
        a%this = ESMF_NULL_POINTER

!
! TODO: add code here
!

        ESMF_InternArrayRead = a 

        if (present(rc)) rc = ESMF_RC_NOT_IMPL

        end function ESMF_InternArrayRead

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArrayReadRestart"
!BOPI
! !IROUTINE: ESMF_InternArrayReadRestart
!
! !INTERFACE:
      function ESMF_InternArrayReadRestart(name, iospec, rc)
!
! !RETURN VALUE:
      type(ESMF_InternArray) :: ESMF_InternArrayReadRestart
!
!
! !ARGUMENTS:
      character (len = *), intent(in) :: name 
      type(ESMF_IOSpec), intent(in), optional :: iospec 
      integer, intent(out), optional :: rc
!
! !DESCRIPTION:
!      Used to reinitialize
!      all data associated with an {\tt ESMF\_Array}
!      from the last call to writerestart.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

        type (ESMF_InternArray) :: a 

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

!       ! this is just to prevent compiler warnings
        a%this = ESMF_NULL_POINTER

!
! TODO: add code here
!

        ESMF_InternArrayReadRestart = a 
 
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

        end function ESMF_InternArrayReadRestart

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_IArraySetAxisIndex"
!BOPI
! !IROUTINE: ESMF_IArraySetAxisIndex
!
! !INTERFACE:
      subroutine ESMF_IArraySetAxisIndex(array, totalindex, compindex, &
                                        exclindex, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(inout) :: array 
      type(ESMF_AxisIndex), intent(inout), optional :: totalindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: compindex(:)
      type(ESMF_AxisIndex), intent(inout), optional :: exclindex(:)
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to annotate an {\tt ESMF\_Array} with information 
!      used to manage halo regions.
!           
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[totalindex]}]
!	    An array of index spaces for the total array size.
!     \item [{[compindex]}]
!	    An array of index spaces for the computational array size.
!     \item [{[exclindex]}]
!	    An array of index spaces for the exclusive array size.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!       
!
!EOPI

        integer :: status
        integer :: i

        ! Initialize return code; assume routine not implemented
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

        ! Check init status of arguments
        ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

        ! call c routine to add index
        if (present(totalindex)) then
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min - 1
            totalindex(i)%max = totalindex(i)%max - 1
          enddo
          call c_ESMC_IArraySetAxisIndex(array, ESMF_DOMAIN_TOTAL, &
                                        totalindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(totalindex)
            totalindex(i)%min = totalindex(i)%min + 1
            totalindex(i)%max = totalindex(i)%max + 1
          enddo
        endif

        if (present(compindex)) then
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min - 1
            compindex(i)%max = compindex(i)%max - 1
          enddo
          call c_ESMC_IArraySetAxisIndex(array, ESMF_DOMAIN_COMPUTATIONAL, &
                                        compindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(compindex)
            compindex(i)%min = compindex(i)%min + 1
            compindex(i)%max = compindex(i)%max + 1
          enddo
        endif

        if (present(exclindex)) then
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min - 1
            exclindex(i)%max = exclindex(i)%max - 1
          enddo
          call c_ESMC_IArraySetAxisIndex(array, ESMF_DOMAIN_EXCLUSIVE, &
                                        exclindex, status)
          if (status .ne. ESMF_SUCCESS) goto 10
          do i=1,size(exclindex)
            exclindex(i)%min = exclindex(i)%min + 1
            exclindex(i)%max = exclindex(i)%max + 1
          enddo
        endif

        status = ESMF_SUCCESS

 10   continue
        if (present(rc)) rc = status
        end subroutine ESMF_IArraySetAxisIndex

!------------------------------------------------------------------------------
! obsolete.  nsc 03nov05
!#undef  ESMF_METHOD
!#define ESMF_METHOD "ESMF_IArrayComputeAxisIndex"
!!BOPI
!! !IROUTINE: ESMF_IArrayComputeAxisIndex
!!
!! !INTERFACE:
!      subroutine ESMF_IArrayComputeAxisIndex(array, delayout, decompids, rc)
!!
!! !ARGUMENTS:
!      type(ESMF_InternArray), intent(inout) :: array 
!      type(ESMF_DELayout), intent(in) :: delayout
!      integer, dimension(:), intent(in) :: decompids
!      integer, intent(out), optional :: rc     
!!
!! !DESCRIPTION:
!!      Used to annotate an {\tt ESMF\_Array} with information 
!!      used to manage halo regions.
!!           
!!     The arguments are:
!!     \begin{description}
!!     \item [array]
!!           An {\tt ESMF\_Array}.
!!     \item [delayout]
!!           The {\tt ESMF\_DELayout} over which this {\tt ESMF\_Array}
!!           is decomposed.
!!     \item [decompids]
!!           An integer array, one index per dimension, identifying
!!           which axes are decomposed and in which order.
!!     \item [{[rc]}]
!!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!!     \end{description}
!!       
!!
!!EOPI
!
!        integer :: status
!        integer :: dlength
!
!        ! call c routine to do work
!        dlength = size(decompids)
!   !     call c_ESMC_IArrayComputeAxisIndex(array, delayout, decompids, &
!   !                                       dlength, status)
!        status = ESMF_FAILURE
!
!        if (present(rc)) rc = status
!
!        end subroutine ESMF_IArrayComputeAxisIndex
!
!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArraySet"
!BOPI
! !IROUTINE: ESMF_InternArraySet - Set information about an Array
!
! !INTERFACE:
      subroutine ESMF_InternArraySet(array, name, rc)

!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(inout) :: array
      character (len = *), intent(in), optional :: name
      integer, intent(out), optional :: rc

!
! !DESCRIPTION:
!     Sets the name of the {\tt ESMF\_Array}.  
!     Note: Unlike most other ESMF objects there are
!     very few items which can be changed once an {\tt ESMF\_Array} 
!     is created.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[name]}]
!           The array name.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

      integer :: status                           ! Error status
      logical :: rcpresent                        ! Return code present

      ! Initialize return code; assume routine not implemented
      status = ESMF_RC_NOT_IMPL
      rcpresent = .FALSE.
      if (present(rc)) then
          rcpresent = .TRUE.
          rc = ESMF_RC_NOT_IMPL
      endif

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

      if (present(name)) then
          call c_ESMC_SetName(array, "Array", name, status)
          if (ESMF_LogMsgFoundError(status, &
                                    ESMF_ERR_PASSTHRU, &
                                    ESMF_CONTEXT, rc)) return
      endif

      if (rcpresent) rc = ESMF_SUCCESS

      end subroutine ESMF_InternArraySet


!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArrayValidate"
!BOPI
! !IROUTINE: ESMF_InternArrayValidate - Check validity of an Array 
!
! !INTERFACE:
  subroutine ESMF_InternArrayValidate(array, options, rc)
!
!
! !ARGUMENTS:
    type(ESMF_InternArray)                        :: array
    character(len = *),   intent(in),   optional  :: options
    integer,              intent(out),  optional  :: rc 
!
! !DESCRIPTION:
!      Validates that the {\tt array} is internally consistent.
!      Currently this method determines if the {\tt array} has a valid
!      data pointer.  The method returns an error code if problems 
!      are found.  
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[options]}]
!           Validation options are not yet supported.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

    character(len=6)  :: defaultopts      ! default print options 
!    integer           :: status           ! local error status

    ! Initialize return code; assume routine not implemented
    if (present(rc)) rc = ESMF_RC_NOT_IMPL
    
    ! Check init status of arguments
    ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)
    
    defaultopts = "brief"

    if(present(options)) then
        !call c_ESMC_IArrayValidate(array, options, status) 
    else
        !call c_ESMC_IArrayValidate(array, defaultopts, status) 
    endif
    !todo: error handling
    
    ! Return successfully
    if (present(rc)) rc = ESMF_SUCCESS

  end subroutine ESMF_InternArrayValidate

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArrayWrite"
!BOPI
! !IROUTINE: ESMF_InternArrayWrite
!
! !INTERFACE:
      subroutine ESMF_InternArrayWrite(array, iospec, filename, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray) :: array
      type(ESMF_IOSpec), intent(in), optional :: iospec
      character(len=*), intent(in), optional :: filename
      integer, intent(out), optional :: rc     
!
! !DESCRIPTION:
!      Used to write data to persistent storage in a variety of formats.  
!      (see writerestart/restore for quick data dumps.)  Details of I/O 
!      options specified with an {\tt ESMF\_IOSpec}.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[filename]}]
!           The file name.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

       character (len=16) :: defaultopts      ! default write options 
       character (len=16) :: defaultfile      ! default filename
       integer :: status                      ! local error status
       logical :: rcpresent        

       ! Initialize return code; assume routine not implemented
       status = ESMF_RC_NOT_IMPL
       rcpresent = .FALSE.
       if (present(rc)) then
         rcpresent = .TRUE.
         rc = ESMF_RC_NOT_IMPL
       endif

      ! Check init status of arguments
      ESMF_INIT_CHECK_DEEP(ESMF_InternArrayGetInit, array, rc)

       defaultopts = "singlefile"
       defaultfile = "datafile"

       if(present(filename)) then
           call c_ESMC_IArrayWrite(array, defaultopts, trim(filename), status) 
       else
           call c_ESMC_IArrayWrite(array, defaultopts, trim(defaultfile), status) 
       endif
       if (ESMF_LogMsgFoundError(status, &
                                 ESMF_ERR_PASSTHRU, &
                                 ESMF_CONTEXT, rc)) return

       ! Set return values
       if (rcpresent) rc = ESMF_SUCCESS

       end subroutine ESMF_InternArrayWrite

!------------------------------------------------------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArrayWriteRestart"
!BOPI
! !IROUTINE: ESMF_InternArrayWriteRestart
!
! !INTERFACE:
      subroutine ESMF_InternArrayWriteRestart(array, iospec, rc)
!
! !ARGUMENTS:
      type(ESMF_InternArray):: array 
      type(ESMF_IOSpec), intent(in), optional :: iospec
      integer, intent(out), optional :: rc            
!
! !DESCRIPTION:
!      Used to save all data to disk as quickly as possible.  
!      (see read/write for other options).  Internally this routine uses the
!      same I/O interface as read/write, but the default options are to
!      select the fastest way to save data to disk.
!     
!     The arguments are:
!     \begin{description}
!     \item [array]
!           An {\tt ESMF\_Array}.
!     \item [{[iospec]}]
!           The file specification.
!     \item [{[rc]}]
!           Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!
!EOPI

!
! TODO: code goes here
!
        if (present(rc)) rc = ESMF_RC_NOT_IMPL

        end subroutine ESMF_InternArrayWriteRestart



! -------------------------- ESMF-public method -------------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArraySetInitCreated()"
!BOPI
! !IROUTINE: ESMF_InternArraySetInitCreated - Set InternArray init code to "CREATED"

! !INTERFACE:
  subroutine ESMF_InternArraySetInitCreated(array, rc)
!
! !ARGUMENTS:
    type(ESMF_InternArray), intent(inout)           :: array
    integer,          intent(out),  optional  :: rc  
!         
!
! !DESCRIPTION:
!      Set init code in InternArray object to "CREATED".
!
!     The arguments are:
!     \begin{description}
!     \item[array] 
!          Specified {\tt ESMF\_InternArray} object.
!     \item[{[rc]}] 
!          Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!     \end{description}
!
!EOPI

!------------------------------------------------------------------------------

    ! Initialize return code; assume routine not implemented
    if (present(rc)) rc = ESMF_RC_NOT_IMPL
    
    ! Set init code
    ESMF_INIT_SET_CREATED(array)

    ! Return success
    if (present(rc)) rc = ESMF_SUCCESS
    
  end subroutine ESMF_InternArraySetInitCreated
!------------------------------------------------------------------------------



! -------------------------- ESMF-internal method -----------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_InternArrayGetInit"
!BOPI
! !IROUTINE: ESMF_InternArrayGetInit - Internal access routine for init code
!
! !INTERFACE:
      function ESMF_InternArrayGetInit(array) 
!
! !RETURN VALUE:
      ESMF_INIT_TYPE :: ESMF_InternArrayGetInit   
!
! !ARGUMENTS:
      type(ESMF_InternArray), intent(in), optional :: array
!
! !DESCRIPTION:
!      Access deep object init code.
!
!     The arguments are:
!     \begin{description}
!     \item [array]
!           InternArray object.
!     \end{description}
!
!EOPI

    if (present(array)) then
      ESMF_InternArrayGetInit = ESMF_INIT_GET(array)
    else
      ESMF_InternArrayGetInit = ESMF_INIT_CREATED
    endif

    end function ESMF_InternArrayGetInit
!------------------------------------------------------------------------------


! -------------------------- ESMF-internal method -----------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_HaloDirectionInit()"
!BOPI
! !IROUTINE: ESMF_HaloDirectionInit - Init HaloDirection internals

! !INTERFACE:
  subroutine ESMF_HaloDirectionInit(halodirection)
!
! !ARGUMENTS:
    type(ESMF_HaloDirection), intent(inout) :: halodirection
!         
!
! !DESCRIPTION:
!      Initialize HaloDirection internals.
!
!     The arguments are:
!     \begin{description}
!     \item[halodirection] 
!          Specified {\tt ESMF\_HaloDirection} object.
!     \end{description}
!
!EOPI
!------------------------------------------------------------------------------
    ESMF_INIT_SET_DEFINED(halodirection)
  end subroutine ESMF_HaloDirectionInit
!------------------------------------------------------------------------------


! -------------------------- ESMF-internal method -----------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_HaloDirectionGetInit"
!BOPI
! !IROUTINE: ESMF_HaloDirectionGetInit - Internal access routine for init code
!
! !INTERFACE:
  function ESMF_HaloDirectionGetInit(halodirection) 
!
! !RETURN VALUE:
      ESMF_INIT_TYPE :: ESMF_HaloDirectionGetInit   
!
! !ARGUMENTS:
      type(ESMF_HaloDirection), intent(in), optional :: halodirection
!
! !DESCRIPTION:
!      Access deep object init code.
!
!     The arguments are:
!     \begin{description}
!     \item [halodirection]
!           HaloDirection object.
!     \end{description}
!
!EOPI

    if (present(halodirection)) then
      ESMF_HaloDirectionGetInit = ESMF_INIT_GET(halodirection)
    else
      ESMF_HaloDirectionGetInit = ESMF_INIT_DEFINED
    endif

  end function ESMF_HaloDirectionGetInit
!------------------------------------------------------------------------------


! -------------------------- ESMF-internal method -----------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_MaskInit()"
!BOPI
! !IROUTINE: ESMF_MaskInit - Init Mask internals

! !INTERFACE:
  subroutine ESMF_MaskInit(mask)
!
! !ARGUMENTS:
    type(ESMF_Mask), intent(inout) :: mask
!         
!
! !DESCRIPTION:
!      Initialize Mask internals.
!
!     The arguments are:
!     \begin{description}
!     \item[mask] 
!          Specified {\tt ESMF\_Mask} object.
!     \end{description}
!
!EOPI
!------------------------------------------------------------------------------
    nullify(mask%maskvals)
    ESMF_INIT_SET_DEFINED(mask)
  end subroutine ESMF_MaskInit
!------------------------------------------------------------------------------


! -------------------------- ESMF-internal method -----------------------------
#undef  ESMF_METHOD
#define ESMF_METHOD "ESMF_MaskGetInit"
!BOPI
! !IROUTINE: ESMF_MaskGetInit - Internal access routine for init code
!
! !INTERFACE:
  function ESMF_MaskGetInit(mask) 
!
! !RETURN VALUE:
      ESMF_INIT_TYPE :: ESMF_MaskGetInit   
!
! !ARGUMENTS:
      type(ESMF_Mask), intent(in), optional :: mask
!
! !DESCRIPTION:
!      Access deep object init code.
!
!     The arguments are:
!     \begin{description}
!     \item [mask]
!           Mask object.
!     \end{description}
!
!EOPI

    if (present(mask)) then
      ESMF_MaskGetInit = ESMF_INIT_GET(mask)
    else
      ESMF_MaskGetInit = ESMF_INIT_DEFINED
    endif

  end function ESMF_MaskGetInit
!------------------------------------------------------------------------------


end module ESMF_InternArrayMod
