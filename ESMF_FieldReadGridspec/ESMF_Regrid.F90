! $Id:  Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2013, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!===============================================================================
!                            ESMF_Regrid.F90
!
! This is an external demo of Field regridding.  The Grids are created
! from GridSpec <version> formatted data files.  The Fields can optionally
! be built from the same files using the 'read_data_from_file' macro.  The 
! weights can be read from SCRIP formatted weights file generated by the 
! ESMF_RegridWeightGen application using the 'read_weights_from_file' macro.
! A regridding operation is performed, and the Field values are printed
! to standard out if the Fields were created from file, and they are 
! validated against an analytic field otherwise.
! 
! NOTE: This demo does not work in parallel if reading data or weights from 
!       file (i.e. if using the read_data_from_file or read_weights_from_file
!       macros below)
!===============================================================================

! - read_data_from_file will create an ESMF Field using data from the source 
!     Grid file, otherwise a constant analytic field will be used.
!
! - read_weights_from_file will create an interpolator to be used in 
!     ESMF_FieldRegrid() by reading the weights from a file created using the
!     ESMF_RegridWeightGen application, otherwise the interpolator will be
!     created during runtime using ESMF_FieldRegridStore()


! TODO: 
! - add this to the repo
! - change decomp to nx1
! - remove the read_data_from_file in favor of analytic field
!    - put the analytic field creation and validation in separate routines
!    - use a more complicated analytic field
! - do everything in parallel (grid is good, so is weights now)
! - modify docs to have a clearly bulleted list of 1, 2, 3

#define read_weights_from_file

program Regrid

  use ESMF

  use ESMF_IOGridspecMod

  use netcdf

  implicit none

  ! -----------------------------------------------------------------------
  integer :: localPet, nPet
  integer :: localrc, rc

  type(ESMF_VM) :: vm

  character(ESMF_MAXPATHLEN) :: srcfile, dstfile, weightfile

  integer :: i, j

  real(ESMF_KIND_R8), parameter :: UNINITVAL = 422397696

  real(ESMF_KIND_R8), allocatable :: FsrcArray(:)
  real(ESMF_KIND_R8), allocatable :: FdstArray(:), FdstArrayX(:)
  real(ESMF_KIND_R8), pointer :: FdstArrayPtr(:)

  type(ESMF_RouteHandle) :: routehandle
  type(ESMF_Grid) :: srcGrid, dstGrid
  type(ESMF_Field) :: srcField, dstField

  integer :: rank, dims(2), dimids(2)
  integer, dimension(2) :: srcgec, dstgec
  real(ESMF_KIND_R8), allocatable :: farraysrc(:,:), farraydst(:,:), &
                                     farraydst_exact(:,:)

  real(ESMF_KIND_R8), pointer  :: factorList(:)
  integer, pointer             :: factorIndexList(:,:)

  real(ESMF_KIND_R8), dimension(1) :: reltotError, reltwoError, avgError
  real(ESMF_KIND_R8), dimension(1) :: totErrDif, twoErrDif, twoErrX
  real(ESMF_KIND_R8), dimension(1) :: err, minerr, maxerr

  real(ESMF_KIND_R8), dimension(1) :: totErrDif_g, twoErrDif_g, twoErrX_g, &
                        minerr_g, maxerr_g, &
                        farraydst_exact_max, farraydst_exact_max_g
  integer :: comm

  real(ESMF_KIND_R8), dimension(1) :: toterrdifflist, toterrdifflistg

#if 0
  real(ESMF_KIND_R8), pointer :: grid1area(:), grid2area(:)
  real(ESMF_KIND_R8), pointer :: grid1areaXX(:), grid2areaXX(:)
#endif

  ! -----------------------------------------------------------------------
  ! Set rc to success
  rc = ESMF_SUCCESS

  ! Initialize ESMF
  call ESMF_Initialize (defaultCalKind=ESMF_CALKIND_GREGORIAN, &
    defaultlogfilename="Regrid.Log", &
    logkindflag=ESMF_LOGKIND_MULTI, rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! set log to flush after every message
  call ESMF_LogSet(flush=.true., rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! get all vm information
  call ESMF_VMGetGlobal(vm, rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! set up local pet info
  call ESMF_VMGet(vm, localPet=localPet, petCount=nPet, rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! -----------------------------------------------------------------------
  ! Create source Grid from file
  srcfile = "data/GRIDSPEC_ACCESS1.nc"
  srcGrid = CreateGridSpecGridFromFile(srcfile)

  ! Get the exclusive bounds from the Grid
  call ESMF_GridGet(srcgrid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
      exclusiveCount=srcgec, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Allocate the Fortran array for the Field
  allocate(farraysrc(srcgec(1), srcgec(2)))

!TODO: remove this in favor of the analytic function, as a routine
!      add comment saying that this is where you would read your data from
!      a netcdf file and create a fortran pointer that can be used to 
!      create an ESMF field

#ifdef read_data_from_file
  ! Read the Field from file
  call ESMF_GridspecInq(srcfile, rank, dims, dimids=dimids)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  call ESMF_GridspecGetVarByName(srcfile, "so", dimids, &
                                 farraysrc, rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  !call pack_and_send_int2D(vm, total, regDecomp(1), PetNo, mask2D, fptrmask, dims)
#else
  farraysrc = 42
#endif

  ! Create the source Field from real data
  srcfield = ESMF_FieldCreate(srcgrid, farraysrc, ESMF_INDEX_GLOBAL, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! -----------------------------------------------------------------------
  ! Create destination Grid from file
  dstfile = "data/so_Omon_GISS-E2.nc"
  dstGrid = CreateGridSpecGridFromFile(dstfile)

  ! Get the exclusive bounds from the Grid
  call ESMF_GridGet(dstgrid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
      exclusiveCount=dstgec, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Allocate the Fortran array for the Field
  allocate(farraydst(dstgec(1), dstgec(2)))
  farraydst = UNINITVAL

  ! Create the destination Field
  dstfield = ESMF_FieldCreate(dstgrid, farraydst, ESMF_INDEX_GLOBAL, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

#ifdef read_weights_from_file
  ! -----------------------------------------------------------------------
  ! Field style regridding using weights from an input file
  weightfile = "data/GRIDSPEC_ACCESS1_to_so_Omon_GISS-E2_bilinear.out"

  ! read in the regriding weights from specified file -> factorList and factorIndex list
  call ReadSCRIPWeightsFile(weightfile, factorList, factorIndexList, rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! store the factorList and factorIndex list into a routehandle for SMM
  call ESMF_FieldSMMStore(srcField=srcField, dstField=dstField, routehandle=routehandle, &
    factorList=factorList, factorIndexList=factorIndexList, rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
#else
  ! Field style regridding generating weights on the fly
  ! compute regridding weights
  call ESMF_FieldRegridStore(srcField, dstField, routehandle=routehandle, &
                             rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
#endif

  ! -----------------------------------------------------------------------
  ! compute a Regrid from srcField to dstField
  call ESMF_FieldRegrid(srcField, dstField, routehandle, &
                        zeroregion=ESMF_REGION_SELECT, rc=localrc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

#ifdef read_data_from_file
  if (localPet == 0) then
    call ESMF_FieldPrint(srcField, rc=rc)
    call ESMF_FieldPrint(dstField, rc=rc)
  endif
#else
  ! -----------------------------------------------------------------------
  ! ERROR ANALYSIS - serial and only applies when NOT using real data
  ! -----------------------------------------------------------------------
  allocate(farraydst_exact(dstgec(1), dstgec(2)))
  farraydst_exact = 42

  totErrDif = 0
  twoErrDif = 0
  twoErrX = 0
  maxerr = 0
  minerr = UNINITVAL
  
  ! destination error
  do i=1,dstgec(1)
    do j=1,dstgec(2)
      ! **this code is for when we are using masking and/or conservative
      ! 1. ignore masked cells
      ! 2. if frac is below .999, then a significant portion of this cell is
      ! missing from the weight calculation and error is misleading
      ! 3. also ignore unitialized cells, for the regional to global cases
      !if (dst_mask(i) /= 0 .and. dst_frac(i) > .999 .and. FdstArray(i) /= UNINITVAL) then
        err = abs(farraydst(i,j)) - abs(farraydst_exact(i,j))
        totErrDif = totErrDif + err
        twoErrDif = twoErrDif + err**2
        twoErrX = twoErrX + farraydst_exact(i,j)**2
        if (err(1) < minerr(1)) minerr = err
        if (err(1) > maxerr(1)) maxerr = err
      !endif
    enddo
  enddo
  
  farraydst_exact_max = maxval(farraydst_exact(:,:))

  call ESMF_VMReduce(vm, totErrDif, totErrDif_g, 1, ESMF_REDUCE_SUM, 0)
  call ESMF_VMReduce(vm, twoErrDif, twoErrDif_g, 1, ESMF_REDUCE_SUM, 0)
  call ESMF_VMReduce(vm, twoErrX, twoErrX_g, 1, ESMF_REDUCE_SUM, 0)
  call ESMF_VMReduce(vm, farraydst_exact_max, farraydst_exact_max_g, 1, &
                     ESMF_REDUCE_MAX, 0)
  call ESMF_VMReduce(vm, maxerr, maxerr_g, 1, ESMF_REDUCE_MAX, 0)
  call ESMF_VMReduce(vm, minerr, minerr_g, 1, ESMF_REDUCE_MIN, 0)

  if (localPet == 0) then
    ! relative error
    reltotError = totErrDif_g/farraydst_exact_max_g
    reltwoError = sqrt(twoErrDif_g)/sqrt(twoErrX_g)
    avgError = (minerr_g + maxerr_g)/2
  endif
  
#if 0
    ! **this code is for when we are using masking and/or conservative
    ! area calculations - use one of src_ or dst_frac, but NOT both!
    allocate(grid1area(src_dim))
    allocate(grid2area(dst_dim))
    allocate(grid1areaXX(src_dim))
    allocate(grid2areaXX(dst_dim))
    grid1area = FsrcArray*src_area*src_frac
  
    ! Only calculate dst area over region that is unmasked and initialized
    grid2area=0.0
    do i=1,dst_dim
       if ((dst_mask(i) /= 0) .and. (FdstArray(i) /=UNINITVAL)) then
          grid2area(i) = FdstArray(i)*dst_area(i)
       endif
    enddo
  
    grid1areaXX = FsrcArray*src_area
    grid2areaXX = FdstArray*dst_area*dst_frac
#endif 

  if (localPet == 0) then
    print *, "  -- Regridding Results -- "
    print *, ""
    print *, "     Absolute error - 1 norm = ", reltotError
    print *, "     Relative error - 2 norm = ", reltwoError
    print *, "     Average error - (SCRIP) = ", avgError
  endif
#if 0
    print *, " "
    print *, "Grid 1 area = ", sum(grid1area)
    print *, "Grid 2 area = ", sum(grid2area)
    print *, "Conservation error = ", abs(sum(grid2area)-sum(grid1area))
  
    deallocate(grid1area)
    deallocate(grid2area)
    deallocate(grid1areaXX)
    deallocate(grid2areaXX)
    deallocate(src_area)
    deallocate(src_frac)
    deallocate(dst_area)
#endif
    deallocate(farraydst_exact)
#endif

  deallocate(farraysrc)
  deallocate(farraydst)

  call ESMF_FieldRegridRelease(routehandle, rc=localrc)

  call ESMF_FieldDestroy(srcfield, rc=localrc)
  call ESMF_FieldDestroy(dstfield, rc=localrc)
  call ESMF_GridDestroy(srcgrid, rc=localrc)
  call ESMF_GridDestroy(dstgrid, rc=localrc)

  call ESMF_Finalize()

contains

! CreateGridSpecGridFromFile - Generate Grid from GridSpec file
  function CreateGridSpecGridFromFile(gridFile, &
    regionalFlag, &
    missingValueFlag, missingValueVar, &
    useCoordFlag, coordinateVars, &
    largefileFlag, &
    netcdf4fileFlag, verboseFlag, rc)

    type(ESMF_Grid) :: CreateGridSpecGridFromFile

    character(len=*),             intent(in)            :: gridFile
    logical,                      intent(in),  optional :: regionalFlag
    logical,                      intent(in),  optional :: missingValueFlag
    character(len=*),             intent(in),  optional :: missingValueVar
    logical,                      intent(in),  optional :: useCoordFlag
    character(len=*),             intent(in),  optional :: coordinateVars(:)
    logical,                      intent(in),  optional :: largefileFlag
    logical,                      intent(in),  optional :: netcdf4fileFlag
    logical,                      intent(in),  optional :: verboseFlag
    integer,                      intent(out), optional :: rc

! !DESCRIPTION:
! This subroutine provides the same function as the {\tt ESMF\_RegridWeightGen} application
! described in Section~\ref{sec:ESMF_RegridWeightGen}.  It takes and returns
! a GridSpec compliant ESMF Grid.
! All the optional arguments are similar to the command line arguments for the {\tt ESMF\_RegridWeightGen}
! application~(\ref{sec:regridusage}). The acceptable values and the default value for the optional arguments
! are listed below.
! 
! The arguments are:
!   \begin{description}
!   \item [gridFile]
!     The source grid file name.
!   \item [{[regionalFlag]}]
!     If .TRUE., the source grid is a regional grid, otherwise,
!     it is a global grid.  The default value is .FALSE.
!   \item [{[missingValueFlag]}]
!     If .TRUE., the source grid mask will be constructed using the missing
!     values of the variable defined in {\tt missingValueVar}. This flag is
!     only used for the grid defined in  the GRIDSPEC or the UGRID file formats.
!     The default value is .FALSE..
!   \item [{[missingValueVar]}]
!     If {\tt missingValueFlag} is .TRUE., the argument is required to define
!     the variable name whose missing values will be used to construct the grid 
!     mask.  It is only used for the grid defined in  the GRIDSPEC or the UGRID 
!     file formats.
!   \item [{[useCoordFlag]}]
!     If .TRUE., the coordinate variables defined in {\tt coordinateVars} will
!     be used as the longitude and latitude variables for the source grid.
!     This flag is only used for the GRIDSPEC file format.  The default is .FALSE.
!   \item [{[coordinateVars]}]
!     If {\tt useCoordFlag} is .TRUE., this argument defines the longitude and
!     latitude variables in the source grid file to be used for the regrid.
!     This argument is only used when the grid file is in GRIDSPEC format.
!     {\tt coordinateVars} should be a array of 2 elements.
!   \item [{[largefileFlag]}]
!     If .TRUE., the output weight file is in NetCDF 64bit offset format. 
!     The default is .FALSE.
!   \item [{[netcdf4fileFlag]}]
!     If .TRUE., the output weight file is in NetCDF4 file format. 
!     The default is .FALSE.
!   \item [{[verboseFlag]}]
!     If .TRUE., it will print summary information about the regrid parameters,
!     default to .FALSE.
!   \item [{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!   \end{description}
!EOP

      
    type(ESMF_FileFormat_Flag)   :: fileType
    logical            :: localLargefileFlag
    logical            :: localNetcdf4fileFlag
    logical            :: localVerboseFlag
    integer            :: localrc
    type(ESMF_VM)      :: vm
    integer            :: PetNo, PetCnt
    integer(ESMF_KIND_I4) :: maskvals(1)
    integer            :: ind
    integer, pointer   :: dims(:)
    integer            :: rank
    logical            :: convert3D
    logical            :: addCorners,convertToDual
    logical            :: isReg, isSphere
    logical            :: isRegional, typeSetFlag
    character(len=256) :: methodStr
    integer            :: i, bigFac, xpets, ypets, xpart, ypart, xdim, ydim
    logical            :: missingValue
    character(len=256) :: argStr, msg
    logical            :: useCoordVar
    integer            :: commandbuf(6)

    !------------------------------------------------------------------------
    ! get global vm information
    !
    call ESMF_VMGetCurrent(vm, rc=localrc)
    if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, file=__FILE__, rcToReturn=rc)) &
      call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! set up local pet info
    call ESMF_VMGet(vm, localPet=PetNo, petCount=PetCnt, rc=localrc)
    if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, file=__FILE__, rcToReturn=rc)) &
      call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Default values
    fileType = ESMF_FILEFORMAT_GRIDSPEC
    localVerboseFlag = .false.
    isRegional = .false.
    missingValue = .false.
    localLargeFileFlag = .false.
    localNetcdf4FileFlag = .false.
    useCoordVar = .false.

    ! If the src grid type is UGRID or GRIDSPEC, check if the missingValueFlag is given 
    if (present(missingValueFlag)) then
      missingValue = missingValueFlag
    else
      missingValue = .false.
    endif
    if (missingValue) then
      if (.not. present(missingValueVar)) then
        write (msg, '(a,i4)') "missingValueVar argument is not given"
        call ESMF_LogSetError(ESMF_RC_ARG_WRONG, msg=msg, &
          line=__LINE__, file=__FILE__ , rcToReturn=rc)
        return
      endif
    endif

    if (present(regionalFlag)) then
      isRegional = regionalFlag
    endif

    if (present(largefileFlag)) then
      localLargeFileFlag = largefileFlag
    endif

    if (present(netcdf4fileFlag)) then
      localNetcdf4FileFlag = netcdf4fileFlag
    endif

    if (present(verboseFlag)) then
         localVerboseFlag = verboseFlag
    endif

    ! --src_coordinates, --dst_coordinates for GRIDSPEC file if there are multiple
    ! coordinate variables
    if (present(useCoordFlag)) then
      useCoordVar = useCoordFlag
    else
      useCoordVar = .false.
    endif
    if (useCoordVar) then
      if (.not. present(coordinateVars)) then
        write (msg, '(a,i4)') "coordinateVars argument is not given."
        call ESMF_LogSetError(ESMF_RC_ARG_WRONG, msg=msg, &
          line=__LINE__, file=__FILE__ , rcToReturn=rc)
        return
      endif
    endif

    ! Should I have only PetNO=0 to open the file and find out the size?
    if (PetNo == 0) then
      if (fileType == ESMF_FILEFORMAT_GRIDSPEC) then
        allocate(dims(2))
        if (useCoordVar) then
          call ESMF_GridspecInq(gridFile, rank, dims, coord_names=coordinateVars, rc=localrc)
        else
          call ESMF_GridspecInq(gridFile, rank, dims, rc=localrc)
        endif
        if (localVerboseFlag .and. localrc /= ESMF_SUCCESS) then 
          write(*,*)
          print *, 'ERROR: Unable to get dimension information from:', gridFile
        endif
        if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
          line=__LINE__, file=__FILE__, rcToReturn=rc)) &
          call ESMF_Finalize(endflag=ESMF_END_ABORT)
        isReg = .true.
        rank = 2
      else
        isReg = .false.
      endif

      commandbuf(:) = 0
      if (isReg) commandbuf(1) = 1
        if (isReg) then
          commandbuf(3) = dims(1)
          commandbuf(4) = dims(2)
        endif 
        call ESMF_VMBroadcast(vm, commandbuf, 6, 0, rc=rc)
        if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
          line=__LINE__, file=__FILE__, rcToReturn=rc)) &
          call ESMF_Finalize(endflag=ESMF_END_ABORT)
    else
    ! Not the Root PET
      allocate(dims(2))
      call ESMF_VMBroadcast(vm, commandbuf, 6, 0, rc=rc)
      if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)) &
        call ESMF_Finalize(endflag=ESMF_END_ABORT)
      if (commandbuf(1) == 1) then
        isReg = .true.
      else
        isReg = .false.
      endif        

      dims(1) = commandbuf(3)  
      dims(2) = commandbuf(4)  
    endif

    ! Print the regrid options
    if (localVerboseFlag .and. PetNo == 0) then
      print *, "Creating Grid with these inputs: "
      print *, "  Grid File: ", trim(gridFile)
      print *, "  Grid File is in GRIDSPEC foramt"
      if (useCoordVar) then
        print *, "    Use '", trim(coordinateVars(1)), "' and '", trim(coordinateVars(2)), &
          "' as the longitude and latitude variables"
      endif
      if (missingValue) then
        print *, "    Use the missing values of variable '", trim(missingValueVar),"' as the mask"
      endif
      if (isRegional) then
        print *, "  Grid is a regional grid"
      else 
        print *, "  Grid is a global grid"
      endif
      if (isReg)   then
        print *, "  Grid is a logically rectangular grid"
      else
        print *, "  Grid is an unstructured grid"
      endif
      if (localLargeFileFlag) then
        print *, "  Output weight file in 64bit offset NetCDF file format"
      endif
      if (localNetcdf4FileFlag) then
        print *, "  Output weight file in NetCDF4 file format"
      endif
      write(*,*)
    endif 

    if (isRegional) then
      isSphere=.false.
    else
      isSphere=.true.
    endif

    ! Create a decomposition such that each PET will contain at least 2 column and 2 row of data
    ! otherwise, regrid will not work
    if (PetCnt == 1) then
      xpart = 1
      ypart = 1
    else
      bigFac = 1
      do i=2, int(sqrt(float(PetCnt)))
        if ((PetCnt/i)*i == PetCnt) then
          bigFac = i
        endif
      enddo
      xpets = bigFac
      ypets = PetCnt/xpets
      if (isReg) then
        if ((dims(1) <= dims(2) .and. xpets <= ypets) .or. &
            (dims(1) > dims(2) .and. xpets > ypets)) then
          xpart = xpets
          ypart = ypets
        else 
        xpart = ypets
        ypart = xpets
      endif
      xdim = dims(1)/xpart
      ydim = dims(2)/ypart
      do while (xdim <= 1 .and. xpart>1)
        xpart = xpart-1
        xdim = dims(1)/xpart
      enddo
      do while (ydim <= 1 .and. ypart>1) 
        ypart = ypart-1
        ydim = dims(2)/ypart
      enddo
    endif
  endif

  !Read in the gridFile and create the corresponding ESMF object (either
  ! ESMF_Grid or ESMF_Mesh
  if (useCoordVar) then
    if (missingValue) then
      CreateGridSpecGridFromFile = ESMF_GridCreate(gridFile, fileType, (/xpart,ypart/), &
                                addCornerStagger=addCorners, &
                                addMask=.true., &
                                varname=trim(missingValueVar), &
                                isSphere=isSphere, &
                                coordNames = coordinateVars, &
                                rc=localrc)
    else
      CreateGridSpecGridFromFile = ESMF_GridCreate(gridFile, fileType, (/xpart,ypart/), & 
                                addCornerStagger=addCorners, &
                                isSphere=isSphere, &
                                coordNames = coordinateVars, &
                                rc=localrc)
    endif
  else 
    if (missingValue) then
      CreateGridSpecGridFromFile = ESMF_GridCreate(gridFile, fileType, (/xpart,ypart/), &
                                addCornerStagger=addCorners, &
                                addMask=.true., &
                                varname=trim(missingValueVar), &
                                isSphere=isSphere, rc=localrc)
    else
      CreateGridSpecGridFromFile = ESMF_GridCreate(gridFile, fileType, (/xpart,ypart/), & 
                                addCornerStagger=addCorners, &
                                isSphere=isSphere, rc=localrc)
    endif
  endif
  if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
    line=__LINE__, file=__FILE__, rcToReturn=rc)) &
    call ESMF_Finalize(endflag=ESMF_END_ABORT)

  !  DESTROY

  end function CreateGridSpecGridFromFile

  subroutine ReadSCRIPWeightsFile(remapFile, factorList, factorIndexList, rc)

    character (ESMF_MAXSTR), intent(in) :: remapFile
    real(ESMF_KIND_R8), pointer         :: factorList(:)
    integer, pointer                    :: factorIndexList(:,:)
    integer, intent(out), optional      :: rc

    !------------------------------------------------------------------------
    !     local variables
    !------------------------------------------------------------------------

    integer :: ncstat,  nc_file_id,  nc_numlinks_id, nc_numwgts_id, &
    nc_dstgrdadd_id, nc_srcgrdadd_id, nc_rmpmatrix_id

    integer :: num_links, num_wts

    character (ESMF_MAXPATHLEN) :: nm, msg

    integer, allocatable  :: address(:), localSize(:), localOffset(:)
    type(ESMF_VM)         :: vm
    integer               :: i, localpet, npet, nlinksPPet, FIndex

    logical :: parallel

    ! get lpe number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc /= ESMF_SUCCESS) then
      write (msg, '(a,i4)') "- failed to get current vm", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    call ESMF_VMGet(vm, localPet=localPet, petCount=npet, rc=rc)
    if(rc /= ESMF_SUCCESS) then
      write (msg, '(a,i4)') "- failed to get current vm", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    if (npet > 1) then
      parallel = .true.
    else 
      parallel = .false. 
    endif

    !-----------------------------------------------------------------------
    !     open remap file and read meta data
    !-----------------------------------------------------------------------
    !-----------------------------------------------------------------
    ! open netcdf file
    !-----------------------------------------------------------------

    ncstat = nf90_open(remapFile, NF90_NOWRITE, nc_file_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_open error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    !-----------------------------------------------------------------------
    ! read source grid meta data for consistency check
    !-----------------------------------------------------------------------
    !-----------------------------------------------------------------
    ! number of address pairs in the remappings
    !-----------------------------------------------------------------

    ncstat = nf90_inq_dimid(nc_file_id, 'n_s', nc_numlinks_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_dimid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    ncstat = nf90_inquire_dimension(nc_file_id, nc_numlinks_id, len=num_links)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inquire_dimension error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    !-----------------------------------------------------------------
    ! number of weights per point/order of interpolation method
    !-----------------------------------------------------------------

    ncstat = nf90_inq_dimid(nc_file_id, 'num_wgts', nc_numwgts_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_dimid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    ncstat = nf90_inquire_dimension(nc_file_id, nc_numwgts_id, len=num_wts)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inquire_dimension error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    FIndex = localPet + 1

    ! split the input data between PETs
    ! allocate factorList and factorIndexList
    if (parallel .eqv. .true.) then
      allocate( localSize(npet), localOffset(npet) )
      nlinksPPet = num_links/npet
      localSize(:) = nlinksPPet
      do i = 1, npet
        localOffset(i) = 1 + (i-1)*nlinksPPet
      enddo
      localSize(npet) = nlinksPPet+MOD(num_links, npet)
  
      allocate( factorIndexList(2,localSize(FIndex)) )
      allocate( factorList(localSize(FIndex)) )
      allocate( address(localSize(FIndex)) )
    else
      allocate( factorIndexList(2,num_links) )
      allocate( factorList(num_links) )
      allocate( address(num_links) )
    endif

    !-----------------------------------------------------------------
    ! source addresses for weights
    !-----------------------------------------------------------------

    ncstat = nf90_inq_varid(nc_file_id, 'col', nc_srcgrdadd_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_varid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    if (parallel .eqv. .true.) then  
      ncstat = nf90_get_var(nc_file_id, nc_srcgrdadd_id, address, &
        start=(/localOffset(FIndex)/), count=(/localSize(FIndex)/))
    else
      ncstat = nf90_get_var(nc_file_id, nc_srcgrdadd_id, address)
    endif
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_get_var error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    factorIndexList(1,:) = address

    !-----------------------------------------------------------------
    ! destination addresss for weights
    !-----------------------------------------------------------------

    ncstat = nf90_inq_varid(nc_file_id, 'row', nc_dstgrdadd_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_varid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    if (parallel .eqv. .true.) then  
      ncstat = nf90_get_var(nc_file_id, nc_dstgrdadd_id, address, &
        start=(/localOffset(FIndex)/), count=(/localSize(FIndex)/))
    else
      ncstat = nf90_get_var(nc_file_id, nc_dstgrdadd_id, address)
    endif
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_get_var error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    factorIndexList(2,:) = address
    deallocate( address )

    !-----------------------------------------------------------------
    !     read all variables
    !-----------------------------------------------------------------

    ncstat = nf90_inq_varid(nc_file_id, 'S', nc_rmpmatrix_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_varid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    if (parallel .eqv. .true.) then  
      ncstat = nf90_get_var(nc_file_id, nc_rmpmatrix_id, factorList, &
        start=(/localOffset(FIndex)/), count=(/localSize(FIndex)/))
    else
      ncstat = nf90_get_var(nc_file_id, nc_rmpmatrix_id, factorList)
    endif
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_get_var error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    !------------------------------------------------------------------------
    !     close input file
    !------------------------------------------------------------------------

    ncstat = nf90_close(nc_file_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_close error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    if(present(rc)) rc = ESMF_SUCCESS

  end subroutine ReadSCRIPWeightsFile

!------------------------------------------------------------------------------
end program Regrid
