! $Id:  Exp $
!
! Earth System Modeling Framework
! Copyright 2002-2013, University Corporation for Atmospheric Research,
! Massachusetts Institute of Technology, Geophysical Fluid Dynamics
! Laboratory, University of Michigan, National Centers for Environmental
! Prediction, Los Alamos National Laboratory, Argonne National Laboratory,
! NASA Goddard Space Flight Center.
! Licensed under the University of Illinois-NCSA License.
!
!===============================================================================
!                            ESMF_Regrid.F90
!
! This is an external demo of Field regridding.  The Grids are created
! from GridSpec(Feb. 9, 2012) formatted data files.  The 
! weights can be read from SCRIP formatted weights file generated by the 
! ESMF_RegridWeightGen application using the 'read_weights_from_file' macro 
! (see the MACRO section below).  This external demo executes a Field
! regridding operation by:
! 
! 1: Create 2 GRIDSPEC grids from file
! 2: Initialize an analytic field on the source Grid
! 3: Read or compute regridding weights
! 4: Execute regridding using ESMF_FieldRegrid()
! 5: Validate interpolated Field against the analytic solution
! 
!===============================================================================

! MACRO: read_weights_from_file will create an interpolation matrix to be used in 
!        ESMF_FieldRegrid() by reading the weights from a file created using the
!        ESMF_RegridWeightGen application.  If this macro is not enabled the \
!        matrix will be created during runtime using ESMF_FieldRegridStore().  In
!        either case an ESMF_RouteHandle is returned, which is used in the 
!        ESMF_FieldRegrid() call to execute the interpolation.


! TODO: 
! - add this to the repo
! *- modify docs to have a clearly bulleted list of 1, 2, 3
! - change decomp to nx1
! *- remove the read_data_from_file in favor of analytic field
!    - put the analytic field creation and validation in separate routines
!    - use a more complicated analytic field
! *- do everything in parallel (grid is good, so is weights now)

#define read_weights_from_file

program Regrid

  use ESMF

  use ESMF_IOGridspecMod

  use netcdf

  implicit none

  ! -----------------------------------------------------------------------
  integer :: rc

  type(ESMF_VM) :: vm

  character(ESMF_MAXPATHLEN) :: srcfile, dstfile, weightfile

  type(ESMF_RouteHandle) :: routehandle
  type(ESMF_Grid) :: srcGrid, dstGrid
  type(ESMF_Field) :: srcField, dstField

  integer, dimension(2) :: srcgec, dstgec
  real(ESMF_KIND_R8), allocatable :: farraysrc(:,:), farraydst(:,:), &
                                     farrayexact(:,:)

  real(ESMF_KIND_R8), pointer  :: factorList(:)
  integer, pointer             :: factorIndexList(:,:)


  ! -----------------------------------------------------------------------
  ! Set rc to success
  rc = ESMF_SUCCESS

  ! Initialize ESMF
  call ESMF_Initialize (defaultCalKind=ESMF_CALKIND_GREGORIAN, &
    defaultlogfilename="Regrid.Log", &
    logkindflag=ESMF_LOGKIND_MULTI, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! set log to flush after every message
  call ESMF_LogSet(flush=.true., rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! get all vm information
  call ESMF_VMGetGlobal(vm, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! -----------------------------------------------------------------------
  ! Create source Grid from file
  srcfile = "data/GRIDSPEC_ACCESS1.nc"
  srcGrid = CreateGridSpecGridFromFile(srcfile)

  ! Get the exclusive bounds from the Grid
  call ESMF_GridGet(srcgrid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
      exclusiveCount=srcgec, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Allocate the Fortran array for the Field
  allocate(farraysrc(srcgec(1), srcgec(2)))

  ! Initialize an analytic field in a Fortran array pointer which will be used
  ! to create an ESMF Field.  The is where you would read from
  ! a GRIDSPEC NetCDF file if you wanted to use physical data 
  call initField(farraysrc, srcGrid, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Create the source Field from real data
  srcfield = ESMF_FieldCreate(srcgrid, farraysrc, ESMF_INDEX_GLOBAL, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! -----------------------------------------------------------------------
  ! Create destination Grid from file
  dstfile = "data/so_Omon_GISS-E2.nc"
  dstGrid = CreateGridSpecGridFromFile(dstfile)

  ! Get the exclusive bounds from the Grid
  call ESMF_GridGet(dstgrid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
      exclusiveCount=dstgec, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! Allocate the Fortran array for the Field
  allocate(farraydst(dstgec(1), dstgec(2)))

  ! Create the destination Field
  dstfield = ESMF_FieldCreate(dstgrid, farraydst, ESMF_INDEX_GLOBAL, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

#ifdef read_weights_from_file
  ! -----------------------------------------------------------------------
  ! Field style regridding using weights from an input file
  weightfile = "data/GRIDSPEC_ACCESS1_to_so_Omon_GISS-E2_bilinear.out"

  ! read in the regriding weights from specified file -> factorList and factorIndex list
  call ReadSCRIPWeightsFile(weightfile, factorList, factorIndexList, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! store the factorList and factorIndex list into a routehandle for SMM
  call ESMF_FieldSMMStore(srcField=srcField, dstField=dstField, &
                          routehandle=routehandle, &
                          factorList=factorList, &
                          factorIndexList=factorIndexList, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
#else
  ! Field style regridding generating weights on the fly
  ! compute regridding weights
  call ESMF_FieldRegridStore(srcField, dstField, routehandle=routehandle, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
#endif

  ! -----------------------------------------------------------------------
  ! compute a Regrid from srcField to dstField
  call ESMF_FieldRegrid(srcField, dstField, routehandle, &
                        zeroregion=ESMF_REGION_SELECT, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! -----------------------------------------------------------------------
  ! initialize the exact solution
  allocate(farrayexact(dstgec(1), dstgec(2)))
  farrayexact = 2.
  !call initField(farrayexact, dstGrid, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! validate the interpolated field against the exact solution
  call validateRegridField(farraydst, farrayexact, dstGrid, rc=rc)
  if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

  ! -----------------------------------------------------------------------
  ! clean up
  call ESMF_FieldRegridRelease(routehandle, rc=rc)

  deallocate(farraysrc)
  deallocate(farraydst)
  deallocate(farrayexact)

  call ESMF_FieldDestroy(srcfield, rc=rc)
  call ESMF_FieldDestroy(dstfield, rc=rc)
  call ESMF_GridDestroy(srcgrid, rc=rc)
  call ESMF_GridDestroy(dstgrid, rc=rc)

  call ESMF_Finalize()

contains

  subroutine initField(farray, grid, rc)

    real(ESMF_KIND_R8), intent(inout) :: farray(:,:)
    type(ESMF_Grid), intent(in)       :: grid
    integer, intent(out), optional    :: rc

    integer :: i, j
    integer, dimension(2) :: ec
    real(ESMF_KIND_R8), pointer :: coordX(:,:), coordY(:,:)
    integer :: clbnd(2),cubnd(2)

    integer :: dimcount

    ! Get the exclusive bounds from the Grid
    call ESMF_GridGet(grid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
        computationalLBound=clbnd, computationalUBound=cubnd, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_GridGet(grid, dimcount=dimcount)
    print *, "dimcount = ", dimcount

    ! get grid coordinatess
    call ESMF_GridGetCoord(grid, localDE=0, &
                           staggerloc=ESMF_STAGGERLOC_CENTER, &
                           coordDim=1, &
                           farrayPtr=coordX, rc=rc)           
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    call ESMF_GridGetCoord(grid, localDE=0, &
                           staggerloc=ESMF_STAGGERLOC_CENTER, &
                           coordDim=2, &
                           farrayPtr=coordY, rc=rc)           
     if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! set the field values

    do i=clbnd(1),cubnd(1)
      do j=clbnd(2),cubnd(2)
        !print *, coordX(i,j), coordY(i,j)
        farray(i,j) = 2.
        !+ coordX(i,j)**2 + coordY(i,j)**2
      enddo
    enddo

    if(present(rc)) rc = ESMF_SUCCESS

  end subroutine initField

  subroutine validateRegridField(interpArray, exactArray, grid, rc)

    real(ESMF_KIND_R8), intent(inout) :: interpArray(:,:)
    real(ESMF_KIND_R8), intent(inout) :: exactArray(:,:)
    type(ESMF_Grid), intent(in)       :: grid
    integer, intent(out), optional    :: rc
  
    integer :: localPet, petCount
    integer :: i, j
    type(ESMF_VM) :: vm
    real(ESMF_KIND_R8), dimension(1) :: reltotError, reltwoError, avgError
    real(ESMF_KIND_R8), dimension(1) :: totErrDif, twoErrDif, twoErrX
    real(ESMF_KIND_R8), dimension(1) :: err, minerr, maxerr
    real(ESMF_KIND_R8), dimension(1) :: totErrDif_g, twoErrDif_g, twoErrX_g, &
                                        minerr_g, maxerr_g, &
                                        analytic_max, analytic_max_g
    real(ESMF_KIND_R8), dimension(1) :: toterrdifflist, toterrdifflistg
    real(ESMF_KIND_R8), allocatable :: analytic(:,:)
    integer, dimension(2) :: ec
    
    call ESMF_VMGetCurrent(vm, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! set up local pet info
    call ESMF_VMGet(vm, localPet=localPet, petCount=petCount, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    ! Get the exclusive bounds from the Grid
    call ESMF_GridGet(grid, localDE=0, staggerloc=ESMF_STAGGERLOC_CENTER, &
        exclusiveCount=ec, rc=rc)
    if (rc /= ESMF_SUCCESS) call ESMF_Finalize(endflag=ESMF_END_ABORT)
  
    totErrDif = 0
    twoErrDif = 0
    twoErrX = 0
    maxerr = 0
    minerr = 256.
    
    ! destination error
    do i=1,ec(1)
      do j=1,ec(2)
        err = abs(interpArray(i,j)) - abs(exactArray(i,j))
        totErrDif = totErrDif + err
        twoErrDif = twoErrDif + err**2
        twoErrX = twoErrX + exactArray(i,j)**2
        if (err(1) < minerr(1)) minerr = err
        if (err(1) > maxerr(1)) maxerr = err
      enddo
    enddo
    
    analytic_max = maxval(exactArray(:,:))
  
    call ESMF_VMReduce(vm, totErrDif, totErrDif_g, 1, ESMF_REDUCE_SUM, 0)
    call ESMF_VMReduce(vm, twoErrDif, twoErrDif_g, 1, ESMF_REDUCE_SUM, 0)
    call ESMF_VMReduce(vm, twoErrX, twoErrX_g, 1, ESMF_REDUCE_SUM, 0)
    call ESMF_VMReduce(vm, analytic_max, analytic_max_g, 1, &
                       ESMF_REDUCE_MAX, 0)
    call ESMF_VMReduce(vm, maxerr, maxerr_g, 1, ESMF_REDUCE_MAX, 0)
    call ESMF_VMReduce(vm, minerr, minerr_g, 1, ESMF_REDUCE_MIN, 0)
  
    if (localPet == 0) then
      ! relative error
      reltotError = totErrDif_g/analytic_max_g
      reltwoError = sqrt(twoErrDif_g)/sqrt(twoErrX_g)
      avgError = (minerr_g + maxerr_g)/2
    endif
    
    if (localPet == 0) then
      print *, "  -- Regridding Results -- "
      print *, ""
      print *, "     Absolute error - 1 norm = ", reltotError
      print *, "     Relative error - 2 norm = ", reltwoError
      print *, "     Average error - (SCRIP) = ", avgError

      if (reltwoError(1) < 10E-12) then
        print *, ""
        print *, "ESMF_Regrid - PASS"
      else
        print *, ""
        print *, "ESMF_Regrid - FAIL"
      endif
    endif

    if(present(rc)) rc = ESMF_SUCCESS

  end subroutine validateRegridField

  ! CreateGridSpecGridFromFile - Generate Grid from GridSpec file
  function CreateGridSpecGridFromFile(gridFile, &
    regionalFlag, &
    missingValueFlag, missingValueVar, &
    useCoordFlag, coordinateVars, &
    largefileFlag, &
    netcdf4fileFlag, verboseFlag, rc)

    type(ESMF_Grid) :: CreateGridSpecGridFromFile

    character(len=*),             intent(in)            :: gridFile
    logical,                      intent(in),  optional :: regionalFlag
    logical,                      intent(in),  optional :: missingValueFlag
    character(len=*),             intent(in),  optional :: missingValueVar
    logical,                      intent(in),  optional :: useCoordFlag
    character(len=*),             intent(in),  optional :: coordinateVars(:)
    logical,                      intent(in),  optional :: largefileFlag
    logical,                      intent(in),  optional :: netcdf4fileFlag
    logical,                      intent(in),  optional :: verboseFlag
    integer,                      intent(out), optional :: rc

! !DESCRIPTION:
! This subroutine provides the same function as the {\tt ESMF\_RegridWeightGen} application
! described in Section~\ref{sec:ESMF_RegridWeightGen}.  It takes and returns
! a GridSpec compliant ESMF Grid.
! All the optional arguments are similar to the command line arguments for the {\tt ESMF\_RegridWeightGen}
! application~(\ref{sec:regridusage}). The acceptable values and the default value for the optional arguments
! are listed below.
! 
! The arguments are:
!   \begin{description}
!   \item [gridFile]
!     The source grid file name.
!   \item [{[regionalFlag]}]
!     If .TRUE., the source grid is a regional grid, otherwise,
!     it is a global grid.  The default value is .FALSE.
!   \item [{[missingValueFlag]}]
!     If .TRUE., the source grid mask will be constructed using the missing
!     values of the variable defined in {\tt missingValueVar}. This flag is
!     only used for the grid defined in  the GRIDSPEC or the UGRID file formats.
!     The default value is .FALSE..
!   \item [{[missingValueVar]}]
!     If {\tt missingValueFlag} is .TRUE., the argument is required to define
!     the variable name whose missing values will be used to construct the grid 
!     mask.  It is only used for the grid defined in  the GRIDSPEC or the UGRID 
!     file formats.
!   \item [{[useCoordFlag]}]
!     If .TRUE., the coordinate variables defined in {\tt coordinateVars} will
!     be used as the longitude and latitude variables for the source grid.
!     This flag is only used for the GRIDSPEC file format.  The default is .FALSE.
!   \item [{[coordinateVars]}]
!     If {\tt useCoordFlag} is .TRUE., this argument defines the longitude and
!     latitude variables in the source grid file to be used for the regrid.
!     This argument is only used when the grid file is in GRIDSPEC format.
!     {\tt coordinateVars} should be a array of 2 elements.
!   \item [{[largefileFlag]}]
!     If .TRUE., the output weight file is in NetCDF 64bit offset format. 
!     The default is .FALSE.
!   \item [{[netcdf4fileFlag]}]
!     If .TRUE., the output weight file is in NetCDF4 file format. 
!     The default is .FALSE.
!   \item [{[verboseFlag]}]
!     If .TRUE., it will print summary information about the regrid parameters,
!     default to .FALSE.
!   \item [{[rc]}]
!     Return code; equals {\tt ESMF\_SUCCESS} if there are no errors.
!   \end{description}
!EOP

      
    integer            :: localrc
    type(ESMF_FileFormat_Flag)   :: fileType
    logical            :: localLargefileFlag
    logical            :: localNetcdf4fileFlag
    logical            :: localVerboseFlag
    type(ESMF_VM)      :: vm
    integer            :: PetNo, PetCnt
    integer(ESMF_KIND_I4) :: maskvals(1)
    integer            :: ind
    integer, pointer   :: dims(:)
    integer            :: rank
    logical            :: convert3D
    logical            :: addCorners,convertToDual
    logical            :: isReg, isSphere
    logical            :: isRegional, typeSetFlag
    character(len=256) :: methodStr
    integer            :: i, bigFac, xpets, ypets, xpart, ypart, xdim, ydim
    character(len=256) :: argStr, msg
    logical            :: useCoordVar
    integer            :: commandbuf(6)

    !------------------------------------------------------------------------
    ! get global vm information
    !
    call ESMF_VMGetCurrent(vm, rc=localrc)
    if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, file=__FILE__, rcToReturn=rc)) &
      call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! set up local pet info
    call ESMF_VMGet(vm, localPet=PetNo, petCount=PetCnt, rc=localrc)
    if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
      line=__LINE__, file=__FILE__, rcToReturn=rc)) &
      call ESMF_Finalize(endflag=ESMF_END_ABORT)

    ! Default values
    fileType = ESMF_FILEFORMAT_GRIDSPEC
    localVerboseFlag = .false.
    isRegional = .false.
    localLargeFileFlag = .false.
    localNetcdf4FileFlag = .false.
    useCoordVar = .false.

    if (present(regionalFlag)) then
      isRegional = regionalFlag
    endif

    if (present(largefileFlag)) then
      localLargeFileFlag = largefileFlag
    endif

    if (present(netcdf4fileFlag)) then
      localNetcdf4FileFlag = netcdf4fileFlag
    endif

    if (present(verboseFlag)) then
         localVerboseFlag = verboseFlag
    endif

    ! --src_coordinates, --dst_coordinates for GRIDSPEC file if there are multiple
    ! coordinate variables
    if (present(useCoordFlag)) then
      useCoordVar = useCoordFlag
    else
      useCoordVar = .false.
    endif
    if (useCoordVar) then
      if (.not. present(coordinateVars)) then
        write (msg, '(a,i4)') "coordinateVars argument is not given."
        call ESMF_LogSetError(ESMF_RC_ARG_WRONG, msg=msg, &
          line=__LINE__, file=__FILE__ , rcToReturn=rc)
        return
      endif
    endif

    ! Should I have only PetNO=0 to open the file and find out the size?
    if (PetNo == 0) then
      if (fileType == ESMF_FILEFORMAT_GRIDSPEC) then
        allocate(dims(2))
        if (useCoordVar) then
          call ESMF_GridspecInq(gridFile, rank, dims, &
                                coord_names=coordinateVars, rc=localrc)
        else
          call ESMF_GridspecInq(gridFile, rank, dims, rc=localrc)
        endif
        if (localVerboseFlag .and. localrc /= ESMF_SUCCESS) then 
          write(*,*)
          print *, 'ERROR: Unable to get dimension information from:', gridFile
        endif
        if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
          line=__LINE__, file=__FILE__, rcToReturn=rc)) &
          call ESMF_Finalize(endflag=ESMF_END_ABORT)
        isReg = .true.
        rank = 2
      else
        isReg = .false.
      endif

      commandbuf(:) = 0
      if (isReg) commandbuf(1) = 1
        if (isReg) then
          commandbuf(3) = dims(1)
          commandbuf(4) = dims(2)
        endif 
        call ESMF_VMBroadcast(vm, commandbuf, 6, 0, rc=localrc)
        if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
          line=__LINE__, file=__FILE__, rcToReturn=rc)) &
          call ESMF_Finalize(endflag=ESMF_END_ABORT)
    else
    ! Not the Root PET
      allocate(dims(2))
      call ESMF_VMBroadcast(vm, commandbuf, 6, 0, rc=localrc)
      if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)) &
        call ESMF_Finalize(endflag=ESMF_END_ABORT)
      if (commandbuf(1) == 1) then
        isReg = .true.
      else
        isReg = .false.
      endif        

      dims(1) = commandbuf(3)  
      dims(2) = commandbuf(4)  
    endif

    ! Print the regrid options
    if (localVerboseFlag .and. PetNo == 0) then
      print *, "Creating Grid with these inputs: "
      print *, "  Grid File: ", trim(gridFile)
      print *, "  Grid File is in GRIDSPEC foramt"
      if (useCoordVar) then
        print *, "    Use '", trim(coordinateVars(1)), "' and '", &
                  trim(coordinateVars(2)), &
                  "' as the longitude and latitude variables"
      endif
      if (isRegional) then
        print *, "  Grid is a regional grid"
      else 
        print *, "  Grid is a global grid"
      endif
      if (isReg)   then
        print *, "  Grid is a logically rectangular grid"
      else
        print *, "  Grid is an unstructured grid"
      endif
      if (localLargeFileFlag) then
        print *, "  Output weight file in 64bit offset NetCDF file format"
      endif
      if (localNetcdf4FileFlag) then
        print *, "  Output weight file in NetCDF4 file format"
      endif
      write(*,*)
    endif 

    if (isRegional) then
      isSphere=.false.
    else
      isSphere=.true.
    endif

    ! Create a decomposition such that each PET will contain at least 
    ! 2 columns and 2 row of datas otherwise, regrid will not work
    if (PetCnt == 1) then
      xpart = 1
      ypart = 1
    else
      bigFac = 1
      do i=2, int(sqrt(float(PetCnt)))
        if ((PetCnt/i)*i == PetCnt) then
          bigFac = i
        endif
      enddo
      xpets = bigFac
      ypets = PetCnt/xpets
      if (isReg) then
        if ((dims(1) <= dims(2) .and. xpets <= ypets) .or. &
            (dims(1) > dims(2) .and. xpets > ypets)) then
          xpart = xpets
          ypart = ypets
        else 
        xpart = ypets
        ypart = xpets
      endif
      xdim = dims(1)/xpart
      ydim = dims(2)/ypart
      do while (xdim <= 1 .and. xpart>1)
        xpart = xpart-1
        xdim = dims(1)/xpart
      enddo
      do while (ydim <= 1 .and. ypart>1) 
        ypart = ypart-1
        ydim = dims(2)/ypart
      enddo
    endif
  endif

  !Read in the gridFile and create the corresponding ESMF object (either
  ! ESMF_Grid or ESMF_Mesh
  if (useCoordVar) then
    CreateGridSpecGridFromFile = ESMF_GridCreate(gridFile, fileType, &
                              (/xpart,ypart/), & 
                              addCornerStagger=addCorners, &
                              isSphere=isSphere, &
                              coordNames = coordinateVars, &
                              rc=localrc)
    
  else 
    CreateGridSpecGridFromFile = ESMF_GridCreate(gridFile, fileType, &
                              (/xpart,ypart/), & 
                              addCornerStagger=addCorners, &
                              isSphere=isSphere, rc=localrc)
  endif
  if (ESMF_LogFoundError(rcToCheck=localrc, msg=ESMF_LOGERR_PASSTHRU, &
    line=__LINE__, file=__FILE__, rcToReturn=rc)) &
    call ESMF_Finalize(endflag=ESMF_END_ABORT)

  end function CreateGridSpecGridFromFile

  subroutine ReadSCRIPWeightsFile(remapFile, factorList, factorIndexList, rc)

    character (ESMF_MAXSTR), intent(in) :: remapFile
    real(ESMF_KIND_R8), pointer         :: factorList(:)
    integer, pointer                    :: factorIndexList(:,:)
    integer, intent(out), optional      :: rc

    !------------------------------------------------------------------------
    !     local variables
    !------------------------------------------------------------------------

    integer :: ncstat,  nc_file_id,  nc_numlinks_id, nc_numwgts_id, &
    nc_dstgrdadd_id, nc_srcgrdadd_id, nc_rmpmatrix_id

    integer :: num_links, num_wts

    character (ESMF_MAXPATHLEN) :: nm, msg

    integer, allocatable  :: address(:), localSize(:), localOffset(:)
    type(ESMF_VM)         :: vm
    integer               :: i, localpet, npet, nlinksPPet, FIndex

    logical :: parallel

    ! get lpe number
    call ESMF_VMGetCurrent(vm, rc=rc)
    if(rc /= ESMF_SUCCESS) then
      write (msg, '(a,i4)') "- failed to get current vm", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    call ESMF_VMGet(vm, localPet=localPet, petCount=npet, rc=rc)
    if(rc /= ESMF_SUCCESS) then
      write (msg, '(a,i4)') "- failed to get current vm", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    if (npet > 1) then
      parallel = .true.
    else 
      parallel = .false. 
    endif

    !-----------------------------------------------------------------------
    !     open remap file and read meta data
    !-----------------------------------------------------------------------
    !-----------------------------------------------------------------
    ! open netcdf file
    !-----------------------------------------------------------------

    ncstat = nf90_open(remapFile, NF90_NOWRITE, nc_file_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_open error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    !-----------------------------------------------------------------------
    ! read source grid meta data for consistency check
    !-----------------------------------------------------------------------
    !-----------------------------------------------------------------
    ! number of address pairs in the remappings
    !-----------------------------------------------------------------

    ncstat = nf90_inq_dimid(nc_file_id, 'n_s', nc_numlinks_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_dimid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    ncstat = nf90_inquire_dimension(nc_file_id, nc_numlinks_id, len=num_links)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inquire_dimension error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    !-----------------------------------------------------------------
    ! number of weights per point/order of interpolation method
    !-----------------------------------------------------------------

    ncstat = nf90_inq_dimid(nc_file_id, 'num_wgts', nc_numwgts_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_dimid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    ncstat = nf90_inquire_dimension(nc_file_id, nc_numwgts_id, len=num_wts)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inquire_dimension error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    FIndex = localPet + 1

    ! split the input data between PETs
    ! allocate factorList and factorIndexList
    if (parallel .eqv. .true.) then
      allocate( localSize(npet), localOffset(npet) )
      nlinksPPet = num_links/npet
      localSize(:) = nlinksPPet
      do i = 1, npet
        localOffset(i) = 1 + (i-1)*nlinksPPet
      enddo
      localSize(npet) = nlinksPPet+MOD(num_links, npet)
  
      allocate( factorIndexList(2,localSize(FIndex)) )
      allocate( factorList(localSize(FIndex)) )
      allocate( address(localSize(FIndex)) )
    else
      allocate( factorIndexList(2,num_links) )
      allocate( factorList(num_links) )
      allocate( address(num_links) )
    endif

    !-----------------------------------------------------------------
    ! source addresses for weights
    !-----------------------------------------------------------------

    ncstat = nf90_inq_varid(nc_file_id, 'col', nc_srcgrdadd_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_varid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    if (parallel .eqv. .true.) then  
      ncstat = nf90_get_var(nc_file_id, nc_srcgrdadd_id, address, &
        start=(/localOffset(FIndex)/), count=(/localSize(FIndex)/))
    else
      ncstat = nf90_get_var(nc_file_id, nc_srcgrdadd_id, address)
    endif
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_get_var error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    factorIndexList(1,:) = address

    !-----------------------------------------------------------------
    ! destination addresss for weights
    !-----------------------------------------------------------------

    ncstat = nf90_inq_varid(nc_file_id, 'row', nc_dstgrdadd_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_varid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    if (parallel .eqv. .true.) then  
      ncstat = nf90_get_var(nc_file_id, nc_dstgrdadd_id, address, &
        start=(/localOffset(FIndex)/), count=(/localSize(FIndex)/))
    else
      ncstat = nf90_get_var(nc_file_id, nc_dstgrdadd_id, address)
    endif
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_get_var error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    factorIndexList(2,:) = address
    deallocate( address )

    !-----------------------------------------------------------------
    !     read all variables
    !-----------------------------------------------------------------

    ncstat = nf90_inq_varid(nc_file_id, 'S', nc_rmpmatrix_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_inq_varid error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    if (parallel .eqv. .true.) then  
      ncstat = nf90_get_var(nc_file_id, nc_rmpmatrix_id, factorList, &
        start=(/localOffset(FIndex)/), count=(/localSize(FIndex)/))
    else
      ncstat = nf90_get_var(nc_file_id, nc_rmpmatrix_id, factorList)
    endif
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_get_var error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif
    !------------------------------------------------------------------------
    !     close input file
    !------------------------------------------------------------------------

    ncstat = nf90_close(nc_file_id)
    if(ncstat /= 0) then
      write (msg, '(a,i4)') "- nf90_close error:", ncstat
      call ESMF_LogSetError(ESMF_RC_SYS, msg=msg, &
        line=__LINE__, file=__FILE__, rcToReturn=rc)
      return
    endif

    if(present(rc)) rc = ESMF_SUCCESS

  end subroutine ReadSCRIPWeightsFile

!------------------------------------------------------------------------------
end program Regrid
